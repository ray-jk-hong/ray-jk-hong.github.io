{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.JPG","path":"img/avatar.JPG","modified":0,"renderable":1},{"_id":"themes/butterfly/source/draw.io/USB结构体.drawio","path":"draw.io/USB结构体.drawio","modified":0,"renderable":1},{"_id":"themes/butterfly/source/draw.io/kvm-qemu添加内存.drawio","path":"draw.io/kvm-qemu添加内存.drawio","modified":0,"renderable":1},{"_id":"themes/butterfly/source/draw.io/test.txt","path":"draw.io/test.txt","modified":0,"renderable":1},{"_id":"themes/butterfly/source/draw.io/未命名绘图.drawio","path":"draw.io/未命名绘图.drawio","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/i2c协议.md","hash":"77473f2c53196385279cd3cfb0dfd9b6d2555824","modified":1722956863630},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1722946893303},{"_id":"themes/butterfly/README.md","hash":"4e01b47448d9f3a02afc04eef644e2321253f6f4","modified":1722946893303},{"_id":"themes/butterfly/README_CN.md","hash":"148da187d16033624ceccce8b8561835296f5a5a","modified":1722946893303},{"_id":"themes/butterfly/_config.yml","hash":"0f30e41f9bedbfaeae259fba4952979114af1632","modified":1722958058709},{"_id":"themes/butterfly/package.json","hash":"314b0271ba3f668d0d6081b499b2d24e90dab25e","modified":1722946893311},{"_id":"themes/butterfly/plugins.yml","hash":"d807fbb62163bb6fc5a83a24ebd69ac14cf45f67","modified":1722946893311},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1722946893302},{"_id":"themes/butterfly/.DS_Store","hash":"9a724c0f7ee603cb6d683a26c9f00f26df83a74f","modified":1722959186685},{"_id":"themes/butterfly/languages/default.yml","hash":"90a6dc361de67532437d819a55ec64945ca5404b","modified":1722946893303},{"_id":"themes/butterfly/languages/en.yml","hash":"af5603b1a888f167dc80be6d53a19437b5cf6bef","modified":1722946893303},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"5004faee365139521f161babd66649a8107e4008","modified":1722946893303},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"03629d1d13a7be09d4933aa5dc0dcbe45e79140c","modified":1722946893303},{"_id":"themes/butterfly/layout/archive.pug","hash":"bb32c9c476372de747dfa563b83f77d7a917a77d","modified":1722946893303},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1722946893303},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1722946893311},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1722946893311},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1722946893311},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1722946893311},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"6e34b565ea013812d5e363b6de5fa1f9078d4e12","modified":1722946893302},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7b4831ae8f8f8c55dd1b856781210c517c63e6dd","modified":1722946893302},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1722946893302},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1722946893302},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"ecec62305aaa596bb1dfbb46c13d06fb5a9628cf","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1722946893305},{"_id":"themes/butterfly/source/.DS_Store","hash":"0326899d45b25c6ce269c1a7ea2ca46461dc8263","modified":1722959191706},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1722946893302},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"db275f7fbe4438b54cd813b695f4834e10aa234f","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1722946893306},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1722946893311},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1722946893312},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1722946893312},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1722946893311},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"2ac43fd4103ba3c6897da7c13015cb05f39fd695","modified":1722946893312},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1722946893312},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"860f967ecf3c6a6ea785b560a7aae4d0757cd18a","modified":1722946893312},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"e196a99733d7f90899bceed5d12488e8234817d5","modified":1722946893312},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a8eef3f37428436554f58a2b6bac7c255fbdf38d","modified":1722946893312},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"96f861151e3b889ef0ffe78821d489ad2625ee43","modified":1722946893312},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1722946893312},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"7caf549810f971c34196fb9deac2d992545bdff9","modified":1722946893312},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"d5c7e61257b08a9648404f6f48ce4d471cd5fa55","modified":1722946893313},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1722946893313},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"e2a8a09bfe47da26eab242a36f516e6c452c799a","modified":1722946893313},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"821e973d41f7b3b64cde91e0e836ea49c43e3c06","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"93229d44b35b9da92e647b89d6d3087085974a29","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"365db87ddfc582bf8c15cb440c48bed95106e4b1","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"418684993a3a3a2ac534257a2d9ecbcead6808c1","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"512c68a22ae4a58d6a6b24b368a0c00c2ccb4fcb","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"1acefc59ead75ebd8cafee36efc7da4fa426d088","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"19773218877281ccffed921431e87148413a7c20","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"5c2a07df5874b5377540884e4da14dd21489378f","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"5cb273e95846874e3a58074074c501df23c5e912","modified":1722946893313},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"830b1d592278b9f676df0cf9a91b1eeda2456aec","modified":1722946893314},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"ffc62222f8d7b4d44c1c0726c8a08824a2201039","modified":1722946893314},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4526c75e5bf84609d67e92b6af3524bcb278e852","modified":1722946893314},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1722946893318},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1722946893318},{"_id":"themes/butterfly/source/img/avatar.png","hash":"0b36c77ba8f9b99336b07a059e45b7dbcbf5ebd9","modified":1722955796959},{"_id":"themes/butterfly/source/css/var.styl","hash":"152b6bd4b6285165541a71f5a1c913f8ee6a602b","modified":1722946893318},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1722946893318},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1722946893319},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1722946893318},{"_id":"themes/butterfly/source/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1722946893319},{"_id":"themes/butterfly/source/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1722946893319},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"63fed4548367a3663cdbaffa1df48167b0a2397b","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"5208fe1e75d97a05fd9bdd6cc53c59d8b741b94b","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1722946893304},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"f50e6a17073677933c5bc78481bf587a4a9e6da0","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"6f310ca7b392021632b987557607d5b6d18052bb","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"5574804fdea5edf7fd52aad2caf030614d5e7f2f","modified":1722946893305},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"1d39670ee6225f85f5c53bf5c84f3fd6e19290e8","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"a096ff8eb6b2a22395be881f827ff2a686ba5596","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"12e57491e94fa00d953bbda9db0b6d6169e2358c","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"bd5ad01277f8c6ddf8a3a29af1518e5fe6eed23f","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"a658a274c5f7896ee5122725bee45548693bdd66","modified":1722946893310},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1722946893311},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1722946893311},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"66f7a8b0cebc05c575ec3cb70b08d6854029d87a","modified":1722946893311},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1722946893310},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f19694a42dbe28eda4b39a1696e8fbcd277bc76c","modified":1722946893314},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"c8ff6ddd5bfe1190b7b8056b68ce41114fd79dcb","modified":1722946893314},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"4dcd468e4d11a0ac75406162678feffcd89fee00","modified":1722946893314},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"94fc033276c34d264cabaeb52c82786440e773f4","modified":1722953748475},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1722946893315},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"18d08be0cd9b1f8c049d4b922e80f8163a55c947","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"134811b2d696f9ed2c0cd578f3886f1c60770c0a","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"a2eb44fa5eaea1325319a2064439cf36d0f35a2f","modified":1722946893315},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6cf26ffb8a0343eda1cde65b6b73b0ddbe8fcfc","modified":1722946893316},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"f845b9b4efdee750f70c023aab27432611f83059","modified":1722946893316},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"b7a6a585dbc38d177c9aba75df3a467415d0488a","modified":1722946893316},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1722946893316},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0db591a1f4ed5adcb8668a549bbee5c9d62682cf","modified":1722946893316},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"e549d24ad81a7d93326a509ff8dcfcc58c80729e","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"d4ebc41b5c855dd75f47de7345d62f85ce7cf073","modified":1722946893316},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1722946893316},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1722946893317},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1722946893317},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"961589da3c0a532c4709a4a4ea96bd579257f766","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"5cddbb5f4eae695a26685e415d821b523e0f17bf","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"909bb5079b26b6ee68177919f522566503654058","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"2d02e52b360f6e6cae47c293ae57ed78e2554663","modified":1722946893317},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1722946893318},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1722946893319},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1722946893318},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1722946893319},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"f7299f9fef5bf94bb58c8cd3be8ee660ad2f9cd4","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"71af0b679e00290b0854384368b3c7e9b3e5f26a","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"c5f7081ca29db8cc80f808dfc29e36d5fa22fd7e","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"3a5ccfc69bd8ccb4b8f3ce3502023f7914f2a022","modified":1722946893306},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"f77f0fdeac2bc8a72f71a58f9b75aa39f0a108c8","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"46aec6466959baec1c3d71a5dbc510fbeb00c91d","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3bc4c1b91568561f0491bdac65b75aa0bfd01f27","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"62f16a602e57e5f7f7c5249dd37b42d436dc032a","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"2d7b0b09678adba09481e3152e0b32962677f650","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0d378ee8a671982a46213a4bfb223b4f3409aea9","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"a9709905593d960954e2dd572f09f48a6c2b1ef7","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"63cea2b5c8f7b59f5919379d61a2bb2ce8ed7623","modified":1722946893307},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"5c29b5887e2e6cd81e1f13b32da53d9c139b788b","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f15699abb8c7a255aabad0222ae53eee387c66a3","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1995a654ba7ad62775a0a6e2922209cd1a85f2e3","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"46865e3f52096acb07d0212174b4e8751b123aea","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"7aa443b4881448979b810864e206e58c9ed787e3","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"53c190f2945d39b2d4c479e3bb1e6c6851d767c2","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6b67982bb7a3713b5bffd6a23ba2810425c504d0","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"2609bc2656aaaa9b59e8d575e711776512a62192","modified":1722946893308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0f0b46d637a9a1b6ae35148923abecc80b866276","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"de2c4d02b520dd49a0a59fc0f33295e5bbb2c624","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"24804ab6da9727ed793655c1262fa3f1a9746f70","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"4104f96faa6040f111ebfb9a90eeb470857c3b86","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"1f9f51023e9e33081c2add2ca73643c0edc5e9d5","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"b928be14d1b47a9fadb1bcc5f5072a7328752d4b","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"3335024ba91f55ccf3858571b7898f46881c455c","modified":1722946893309},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1722946893314},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"3ba49cfe186e9ca05faf9f0d0113611ec47e9b38","modified":1722946893309},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1722946893310},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1722946893315},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1722946893315},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1722946893315},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"25914321762e30aacc610bc4dfb9de3e1cb556a3","modified":1722946893315},{"_id":"public/content.json","hash":"2e7055f99accc6ff041c0c89eb9d090796041aaa","modified":1723203118569},{"_id":"public/2024/08/06/i2c协议/index.html","hash":"874a4c71c2b6adf57582e99142767fc14e30fc6d","modified":1722958082371},{"_id":"public/archives/index.html","hash":"20a9a30de62a65771c73b99899edf58e2e4de9e3","modified":1723203118569},{"_id":"public/archives/2024/08/index.html","hash":"b453696745950bc48c3b73604afd0dcb9606e186","modified":1723203118569},{"_id":"public/archives/2024/index.html","hash":"8299db7e7a5fd28cf260f0a84cd168b05cc6f3a1","modified":1723203118569},{"_id":"public/index.html","hash":"5d8f69ade7c1ff604e9295ab123c811f4817042d","modified":1723203118569},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1722956996971},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1722956996971},{"_id":"public/img/avatar.png","hash":"0b36c77ba8f9b99336b07a059e45b7dbcbf5ebd9","modified":1722956996971},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1722956996971},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1722956996971},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1722956996971},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1722956996971},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1722956996971},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1722956996971},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1722956996971},{"_id":"public/css/index.css","hash":"e6d66ab7bbc382088c0ee9042093c37b1e18aaa5","modified":1722956996971},{"_id":"themes/butterfly/source/img/avatar.JPG","hash":"8f393cf35ca25ce834024337a3b9d82794089451","modified":1722957915000},{"_id":"public/img/avatar.JPG","hash":"8f393cf35ca25ce834024337a3b9d82794089451","modified":1722958082371},{"_id":"source/_posts/Ftrace.md","hash":"654fca26d0d7d6a87971900def779b2d786d76a1","modified":1723203112418},{"_id":"source/_posts/DeviceModel.md","hash":"00bf95d8f5d8fb24175a3b7268d82e579b913690","modified":1723200795489},{"_id":"source/.DS_Store","hash":"a46f928d1da28d5ab3360f7d24e3dccb59561b1c","modified":1723200883741},{"_id":"source/_posts/FileSystem.md","hash":"75d776074cc963de83ab90cab35199700e5bce3a","modified":1723200795489},{"_id":"source/_posts/HugeTLB.md","hash":"87753e9307e03750e8018d7da67b995d2c415cb8","modified":1723200795489},{"_id":"source/_posts/GIC.md","hash":"45df94ff23ca7fa168aa1c38de645b6b35c0bb95","modified":1723200795489},{"_id":"source/_posts/Kprobe.md","hash":"fbfe1ef4df7a19ffb70ef8dee1b84a72a88a3d72","modified":1723200795490},{"_id":"source/_posts/I2C Protocol.md","hash":"1456e77f4c36c0e7660922e9fbfd87886f9a1093","modified":1723200795490},{"_id":"source/_posts/ProcessSchedule","hash":"99db8028a63d05a6844eee580d38e94a6dab48bc","modified":1723203112418},{"_id":"source/_posts/Rcu.md","hash":"44f7b776c6d434233a8398298717d8c8ae32aadb","modified":1723200795490},{"_id":"source/_posts/Kvm.md","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1723200795490},{"_id":"source/_posts/MMU.md","hash":"36710295cef82af3907d40bc48f0a72fb017cf37","modified":1723200795490},{"_id":"source/_posts/TraceEvent.md","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1723203112419},{"_id":"source/_posts/Spinlock.md","hash":"7bb4125b5ed1f1114ccaf31f785970f14bac19d2","modified":1723200795490},{"_id":"source/_posts/Workqueue.md","hash":"7c16c45b40ce67b26a8a2343939f8f5a4e17b571","modified":1723200795490},{"_id":"source/_posts/Tasklet.md","hash":"aacae9d191c07aa1dc88d77c21c25886351a3529","modified":1723200795490},{"_id":"source/_posts/TTBR0-TTBR1地址范围和选择.drawio.svg","hash":"75a9af4c5d35746db934a154b8196a28f916b929","modified":1723200795490},{"_id":"themes/butterfly/source/draw.io/未命名绘图.drawio","hash":"7524effdb40f7f6adb5dbef69b5d010fd7f81e0b","modified":1723200795491},{"_id":"themes/butterfly/source/draw.io/USB结构体.drawio","hash":"5552c75ca2d5545f11ec44197af4437e0d92482c","modified":1723200795491},{"_id":"themes/butterfly/source/draw.io/kvm-qemu添加内存.drawio","hash":"20888a5668bbd8a8e186d9186550e0406a690a5f","modified":1723200795491},{"_id":"themes/butterfly/source/draw.io/test.txt","hash":"7d0a1e6a061b02ee7d07bf65462298f22eb0c770","modified":1722959220021},{"_id":"public/2024/08/09/Ftrace/index.html","hash":"5e22008680bf217e29e940459d838a7c573256c5","modified":1723203118569},{"_id":"public/2024/08/09/TraceEvent/index.html","hash":"911a7230a8b9a15bc56c86618050a4a08a71c4d3","modified":1723203118569},{"_id":"public/2024/08/09/Kprobe/index.html","hash":"d3124df39cd462f4e65e5c02d3653b20c23a7239","modified":1723203118569},{"_id":"public/2024/08/09/Kvm/index.html","hash":"3a2d6224431220142bebd0c3855124305796c654","modified":1723203118569},{"_id":"public/2024/08/09/Rcu/index.html","hash":"b7bf2aaf1ea89e85258957c4c55871bb3ad2838c","modified":1723203118569},{"_id":"public/2024/08/09/MMU/index.html","hash":"c7729b06ec505c6046703841ea8a6d2337558f1e","modified":1723203118569},{"_id":"public/2024/08/09/Spinlock/index.html","hash":"5fcf5a811b395f2e4e6f03e07cde6ac3346111a1","modified":1723203118569},{"_id":"public/2024/08/09/Tasklet/index.html","hash":"2513e581822c05e026e4a7bfd344332405febffe","modified":1723203118569},{"_id":"public/2024/08/09/Workqueue/index.html","hash":"8ae3705e2b625576617a0afe27d7607204df6c5e","modified":1723203118569},{"_id":"public/2024/08/09/DeviceModel/index.html","hash":"54a47961973ac6c32526099282e4bb4bfe6cfb0e","modified":1723203118569},{"_id":"public/2024/08/09/FileSystem/index.html","hash":"98809253206cb8e51318f7890acc2216a94e1247","modified":1723203118569},{"_id":"public/2024/08/09/GIC/index.html","hash":"d98dd466c8bc7b4bb29492556a1ae9ea06c90452","modified":1723203118569},{"_id":"public/2024/08/09/HugeTLB/index.html","hash":"de1e4a54333a4547454456fbbd3f35f9ff7ee447","modified":1723203118569},{"_id":"public/2024/08/09/I2C Protocol/index.html","hash":"f1e31d62e2877b6f17090a15b11c64874afbd328","modified":1723203118569},{"_id":"public/archives/page/2/index.html","hash":"3e92d203dffbaac350ced5a52baca0fa953a2cf5","modified":1723203118569},{"_id":"public/archives/2024/page/2/index.html","hash":"dee7bda09a85eca849d2baff110022f4faff0b5d","modified":1723203118569},{"_id":"public/archives/2024/08/page/2/index.html","hash":"4cea2da71abd002360f192e42a8dbef97cadd9a8","modified":1723203118569},{"_id":"public/page/2/index.html","hash":"b2628073a44eaad949073b7e369cea7d2577bb6f","modified":1723203118569},{"_id":"public/draw.io/kvm-qemu添加内存.drawio","hash":"20888a5668bbd8a8e186d9186550e0406a690a5f","modified":1723203118569},{"_id":"public/draw.io/未命名绘图.drawio","hash":"7524effdb40f7f6adb5dbef69b5d010fd7f81e0b","modified":1723203118569},{"_id":"public/draw.io/test.txt","hash":"7d0a1e6a061b02ee7d07bf65462298f22eb0c770","modified":1723203118569},{"_id":"public/draw.io/USB结构体.drawio","hash":"5552c75ca2d5545f11ec44197af4437e0d92482c","modified":1723203118569}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"DeviceModel","_content":"\n","source":"_posts/DeviceModel.md","raw":"---\ntitle: DeviceModel\n---\n\n","slug":"DeviceModel","published":1,"date":"2024-08-09T10:53:15.489Z","updated":"2024-08-09T10:53:15.489Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vr0000cbq20w7a6g7w","content":"","cover":false,"excerpt":"","more":""},{"title":"FileSystem","_content":"\n","source":"_posts/FileSystem.md","raw":"---\ntitle: FileSystem\n---\n\n","slug":"FileSystem","published":1,"date":"2024-08-09T10:53:15.489Z","updated":"2024-08-09T10:53:15.489Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vt0001cbq2a6nofvmd","content":"","cover":false,"excerpt":"","more":""},{"title":"Ftrace","_content":"\n## Ftrace原理\ngcc编译时添加-pg编译选项。这个编译选项在函数开始处添加-bl指令\n\n## Ftrace跟踪函数\n\ncd /sys/kernel/debug/tracing/\necho 0 > tracing_on\necho 5 > max_graph_depth\necho function_graph > current_tracer\necho 1 > options/func_stack_trace\necho xxx > set_graph_function     ## set_ftrace_filter这个只能打印本函数没法打印子函数等，而set_graph_function是可以打印子函数，而且可以看到函数是不是在执行过程中被中断切出去了\necho 0 > trace  \necho 1 > tracing_on\n\n./a.out 执行完程序\necho 0 > tracing_on\ncat trace\n\n\nhttps://www.cnblogs.com/arnoldlu/p/7211249.html\n\n### set_graph_function\nIf you want to trace only one function and all of its children,\nyou just have to echo its name into set_graph_function:\n\n\n## Trace-cmd\nhttps://man7.org/linux/man-pages/man1/trace-cmd-record.1.html\n使用trace-cmd record -e workqueue:workqueue_queue_work查看workqueue在执行时cpu 100%的问题\nhttps://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2\n\n## Trace Event\n\n### Trace Event添加\n\n### 应用\n\n## 参考\nhttps://docs.kernel.org/trace/tracepoints.html\nhttps://www.kernel.org/doc/Documentation/trace/ftrace.txt\n","source":"_posts/Ftrace.md","raw":"---\ntitle: Ftrace\n---\n\n## Ftrace原理\ngcc编译时添加-pg编译选项。这个编译选项在函数开始处添加-bl指令\n\n## Ftrace跟踪函数\n\ncd /sys/kernel/debug/tracing/\necho 0 > tracing_on\necho 5 > max_graph_depth\necho function_graph > current_tracer\necho 1 > options/func_stack_trace\necho xxx > set_graph_function     ## set_ftrace_filter这个只能打印本函数没法打印子函数等，而set_graph_function是可以打印子函数，而且可以看到函数是不是在执行过程中被中断切出去了\necho 0 > trace  \necho 1 > tracing_on\n\n./a.out 执行完程序\necho 0 > tracing_on\ncat trace\n\n\nhttps://www.cnblogs.com/arnoldlu/p/7211249.html\n\n### set_graph_function\nIf you want to trace only one function and all of its children,\nyou just have to echo its name into set_graph_function:\n\n\n## Trace-cmd\nhttps://man7.org/linux/man-pages/man1/trace-cmd-record.1.html\n使用trace-cmd record -e workqueue:workqueue_queue_work查看workqueue在执行时cpu 100%的问题\nhttps://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2\n\n## Trace Event\n\n### Trace Event添加\n\n### 应用\n\n## 参考\nhttps://docs.kernel.org/trace/tracepoints.html\nhttps://www.kernel.org/doc/Documentation/trace/ftrace.txt\n","slug":"Ftrace","published":1,"date":"2024-08-09T11:31:52.418Z","updated":"2024-08-09T11:31:52.418Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vu0002cbq28v7r9l1p","content":"<h2 id=\"Ftrace原理\"><a href=\"#Ftrace原理\" class=\"headerlink\" title=\"Ftrace原理\"></a>Ftrace原理</h2><p>gcc编译时添加-pg编译选项。这个编译选项在函数开始处添加-bl指令</p>\n<h2 id=\"Ftrace跟踪函数\"><a href=\"#Ftrace跟踪函数\" class=\"headerlink\" title=\"Ftrace跟踪函数\"></a>Ftrace跟踪函数</h2><p>cd &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;<br>echo 0 &gt; tracing_on<br>echo 5 &gt; max_graph_depth<br>echo function_graph &gt; current_tracer<br>echo 1 &gt; options&#x2F;func_stack_trace<br>echo xxx &gt; set_graph_function     ## set_ftrace_filter这个只能打印本函数没法打印子函数等，而set_graph_function是可以打印子函数，而且可以看到函数是不是在执行过程中被中断切出去了<br>echo 0 &gt; trace<br>echo 1 &gt; tracing_on</p>\n<p>.&#x2F;a.out 执行完程序<br>echo 0 &gt; tracing_on<br>cat trace</p>\n<p><a href=\"https://www.cnblogs.com/arnoldlu/p/7211249.html\">https://www.cnblogs.com/arnoldlu/p/7211249.html</a></p>\n<h3 id=\"set-graph-function\"><a href=\"#set-graph-function\" class=\"headerlink\" title=\"set_graph_function\"></a>set_graph_function</h3><p>If you want to trace only one function and all of its children,<br>you just have to echo its name into set_graph_function:</p>\n<h2 id=\"Trace-cmd\"><a href=\"#Trace-cmd\" class=\"headerlink\" title=\"Trace-cmd\"></a>Trace-cmd</h2><p><a href=\"https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html\">https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html</a><br>使用trace-cmd record -e workqueue:workqueue_queue_work查看workqueue在执行时cpu 100%的问题<br><a href=\"https://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2\">https://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2</a></p>\n<h2 id=\"Trace-Event\"><a href=\"#Trace-Event\" class=\"headerlink\" title=\"Trace Event\"></a>Trace Event</h2><h3 id=\"Trace-Event添加\"><a href=\"#Trace-Event添加\" class=\"headerlink\" title=\"Trace Event添加\"></a>Trace Event添加</h3><h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://docs.kernel.org/trace/tracepoints.html\">https://docs.kernel.org/trace/tracepoints.html</a><br><a href=\"https://www.kernel.org/doc/Documentation/trace/ftrace.txt\">https://www.kernel.org/doc/Documentation/trace/ftrace.txt</a></p>\n","cover":false,"excerpt":"","more":"<h2 id=\"Ftrace原理\"><a href=\"#Ftrace原理\" class=\"headerlink\" title=\"Ftrace原理\"></a>Ftrace原理</h2><p>gcc编译时添加-pg编译选项。这个编译选项在函数开始处添加-bl指令</p>\n<h2 id=\"Ftrace跟踪函数\"><a href=\"#Ftrace跟踪函数\" class=\"headerlink\" title=\"Ftrace跟踪函数\"></a>Ftrace跟踪函数</h2><p>cd &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;<br>echo 0 &gt; tracing_on<br>echo 5 &gt; max_graph_depth<br>echo function_graph &gt; current_tracer<br>echo 1 &gt; options&#x2F;func_stack_trace<br>echo xxx &gt; set_graph_function     ## set_ftrace_filter这个只能打印本函数没法打印子函数等，而set_graph_function是可以打印子函数，而且可以看到函数是不是在执行过程中被中断切出去了<br>echo 0 &gt; trace<br>echo 1 &gt; tracing_on</p>\n<p>.&#x2F;a.out 执行完程序<br>echo 0 &gt; tracing_on<br>cat trace</p>\n<p><a href=\"https://www.cnblogs.com/arnoldlu/p/7211249.html\">https://www.cnblogs.com/arnoldlu/p/7211249.html</a></p>\n<h3 id=\"set-graph-function\"><a href=\"#set-graph-function\" class=\"headerlink\" title=\"set_graph_function\"></a>set_graph_function</h3><p>If you want to trace only one function and all of its children,<br>you just have to echo its name into set_graph_function:</p>\n<h2 id=\"Trace-cmd\"><a href=\"#Trace-cmd\" class=\"headerlink\" title=\"Trace-cmd\"></a>Trace-cmd</h2><p><a href=\"https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html\">https://man7.org/linux/man-pages/man1/trace-cmd-record.1.html</a><br>使用trace-cmd record -e workqueue:workqueue_queue_work查看workqueue在执行时cpu 100%的问题<br><a href=\"https://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2\">https://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2</a></p>\n<h2 id=\"Trace-Event\"><a href=\"#Trace-Event\" class=\"headerlink\" title=\"Trace Event\"></a>Trace Event</h2><h3 id=\"Trace-Event添加\"><a href=\"#Trace-Event添加\" class=\"headerlink\" title=\"Trace Event添加\"></a>Trace Event添加</h3><h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://docs.kernel.org/trace/tracepoints.html\">https://docs.kernel.org/trace/tracepoints.html</a><br><a href=\"https://www.kernel.org/doc/Documentation/trace/ftrace.txt\">https://www.kernel.org/doc/Documentation/trace/ftrace.txt</a></p>\n"},{"title":"GIC","_content":"","source":"_posts/GIC.md","raw":"---\ntitle: GIC\n---\n","slug":"GIC","published":1,"date":"2024-08-09T10:53:15.489Z","updated":"2024-08-09T10:53:15.489Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vv0003cbq2hd358ptf","content":"","cover":false,"excerpt":"","more":""},{"title":"大页机制","_content":"## 参考\nhttps://blog.csdn.net/wangquan1992/article/details/103963108\nhttps://blog.csdn.net/hbuxiaofei/article/details/128402495\nhttps://blog.csdn.net/tony_vip/article/details/113791585\n\nhttps://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf\n\n## 为什么使用大页   \n#### 大页提高性能\n大页能提高性能的原理：MMU翻译页表，按照2MB翻译，到PMD这层就可以了，不用翻译到PTE阶段。\n\n## 大页类型\n### HugeTLB机制： \n   hstate管理大页，从伙伴系统申请，由order值决定大小。小于order的由伙伴系统申请，大于order的由memblock预留内存中申请或者调用alloc_cont_range申请。\n   HugeTLB机制：hugetlbfs文件系统\n   (1) HugeTLB就是透过hugetlbfs方式向文件系统提供使用HugeTLB大页机制\n   (2) hugetlbfs创建的文件可以被读系统调用操作，但不允许写系统调用操作，可以mmap映射\n\n### 复合大页（Compound pages）：多个page组合起来管理连续内存空间\n### 透明大页（Transparent Huge Pages）：伙伴系统直接动态分配\n   透明大页机制介绍：khugepaged线程\n   1) Hash表是为了便于通过mm_struct指针地址，来找到对应的mm_slot结构\n   2) Khugepaged_scan管理的链表是透明大页遍历扫描的链表，透明大页遍历每个mm_slot 的mm_struct\n   3) 通过mm_struct，遍历每个vma数据结构，扫描vma的地址空间，每次按2M大小扫描对应的pte内容\n   透明大页由于性能抖动以及挂死等问题，被禁用：\n   https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/\n\n## 配置使用大页内存\n#### 用户态使用大页\n   用户态使用大页有以下几种方法：\n   - mount一个特殊的hugetlbfs文件系统，在上面创建文件，然后用mmap()进行访问, 但文件是只读的。也可以使用libhugetlbfs。\n   - shmget/shmat，调用shmget申请共享内存加上SHM_HUGETLB标志。\n   - mmap()时指定MAAP_HUGETLB标志。\n   - memfd的memfd_create传MFD_HUGETLB标记\n     \n##### mmap方式使用示例\n1) cat /proc/meminfo | grep -i huge查看大页预留情况\n   AnonHugePages:      2048 kB\n   HugePages_Total:     200\n   HugePages_Free:      200\n   HugePages_Rsvd:        0\n   HugePages_Surp:        0\n   Hugepagesize:       2048 kB\n2) 预留大页（200个大页）\n   echo 200 > /proc/sys/vm/nr_huagepages\n   或者\n   sysctl vm.nr_hugepages=200\n3) mmap + memset的时候，在mmap参数中添加MAP_HUGETLB申请使用大页\n   例如：\n   (1) 申请使用大页\n      size = 2 * 1024 * 1024;\n      addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | 0x40000 /*MAP_HUGETLB*/, -1, 0);\n      memset(addr, 0, size);\n   (2) 重新查看大页使用情况\n      AnonHugePages:      2048 kB\n      HugePages_Total:     200\n      HugePages_Free:      199\n      HugePages_Rsvd:        0\n      HugePages_Surp:        0\n      Hugepagesize:       2048 kB\n##### mount hugetlbfs方式示例\n   libhugetlbfs：使用大页，将用户态程序的text/data/BSS保存到大页功能，提高性能\n##### shmemget方式示例\n   shmem大页：https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux\n#### 内核态申请大页\n\n\n","source":"_posts/HugeTLB.md","raw":"---\ntitle: 大页机制\n---\n## 参考\nhttps://blog.csdn.net/wangquan1992/article/details/103963108\nhttps://blog.csdn.net/hbuxiaofei/article/details/128402495\nhttps://blog.csdn.net/tony_vip/article/details/113791585\n\nhttps://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf\n\n## 为什么使用大页   \n#### 大页提高性能\n大页能提高性能的原理：MMU翻译页表，按照2MB翻译，到PMD这层就可以了，不用翻译到PTE阶段。\n\n## 大页类型\n### HugeTLB机制： \n   hstate管理大页，从伙伴系统申请，由order值决定大小。小于order的由伙伴系统申请，大于order的由memblock预留内存中申请或者调用alloc_cont_range申请。\n   HugeTLB机制：hugetlbfs文件系统\n   (1) HugeTLB就是透过hugetlbfs方式向文件系统提供使用HugeTLB大页机制\n   (2) hugetlbfs创建的文件可以被读系统调用操作，但不允许写系统调用操作，可以mmap映射\n\n### 复合大页（Compound pages）：多个page组合起来管理连续内存空间\n### 透明大页（Transparent Huge Pages）：伙伴系统直接动态分配\n   透明大页机制介绍：khugepaged线程\n   1) Hash表是为了便于通过mm_struct指针地址，来找到对应的mm_slot结构\n   2) Khugepaged_scan管理的链表是透明大页遍历扫描的链表，透明大页遍历每个mm_slot 的mm_struct\n   3) 通过mm_struct，遍历每个vma数据结构，扫描vma的地址空间，每次按2M大小扫描对应的pte内容\n   透明大页由于性能抖动以及挂死等问题，被禁用：\n   https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/\n\n## 配置使用大页内存\n#### 用户态使用大页\n   用户态使用大页有以下几种方法：\n   - mount一个特殊的hugetlbfs文件系统，在上面创建文件，然后用mmap()进行访问, 但文件是只读的。也可以使用libhugetlbfs。\n   - shmget/shmat，调用shmget申请共享内存加上SHM_HUGETLB标志。\n   - mmap()时指定MAAP_HUGETLB标志。\n   - memfd的memfd_create传MFD_HUGETLB标记\n     \n##### mmap方式使用示例\n1) cat /proc/meminfo | grep -i huge查看大页预留情况\n   AnonHugePages:      2048 kB\n   HugePages_Total:     200\n   HugePages_Free:      200\n   HugePages_Rsvd:        0\n   HugePages_Surp:        0\n   Hugepagesize:       2048 kB\n2) 预留大页（200个大页）\n   echo 200 > /proc/sys/vm/nr_huagepages\n   或者\n   sysctl vm.nr_hugepages=200\n3) mmap + memset的时候，在mmap参数中添加MAP_HUGETLB申请使用大页\n   例如：\n   (1) 申请使用大页\n      size = 2 * 1024 * 1024;\n      addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | 0x40000 /*MAP_HUGETLB*/, -1, 0);\n      memset(addr, 0, size);\n   (2) 重新查看大页使用情况\n      AnonHugePages:      2048 kB\n      HugePages_Total:     200\n      HugePages_Free:      199\n      HugePages_Rsvd:        0\n      HugePages_Surp:        0\n      Hugepagesize:       2048 kB\n##### mount hugetlbfs方式示例\n   libhugetlbfs：使用大页，将用户态程序的text/data/BSS保存到大页功能，提高性能\n##### shmemget方式示例\n   shmem大页：https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux\n#### 内核态申请大页\n\n\n","slug":"HugeTLB","published":1,"date":"2024-08-09T10:53:15.489Z","updated":"2024-08-09T10:53:15.489Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vv0004cbq202l33ixw","content":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/wangquan1992/article/details/103963108\">https://blog.csdn.net/wangquan1992/article/details/103963108</a><br><a href=\"https://blog.csdn.net/hbuxiaofei/article/details/128402495\">https://blog.csdn.net/hbuxiaofei/article/details/128402495</a><br><a href=\"https://blog.csdn.net/tony_vip/article/details/113791585\">https://blog.csdn.net/tony_vip/article/details/113791585</a></p>\n<p><a href=\"https://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf\">https://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf</a></p>\n<h2 id=\"为什么使用大页\"><a href=\"#为什么使用大页\" class=\"headerlink\" title=\"为什么使用大页\"></a>为什么使用大页</h2><h4 id=\"大页提高性能\"><a href=\"#大页提高性能\" class=\"headerlink\" title=\"大页提高性能\"></a>大页提高性能</h4><p>大页能提高性能的原理：MMU翻译页表，按照2MB翻译，到PMD这层就可以了，不用翻译到PTE阶段。</p>\n<h2 id=\"大页类型\"><a href=\"#大页类型\" class=\"headerlink\" title=\"大页类型\"></a>大页类型</h2><h3 id=\"HugeTLB机制：\"><a href=\"#HugeTLB机制：\" class=\"headerlink\" title=\"HugeTLB机制：\"></a>HugeTLB机制：</h3><p>   hstate管理大页，从伙伴系统申请，由order值决定大小。小于order的由伙伴系统申请，大于order的由memblock预留内存中申请或者调用alloc_cont_range申请。<br>   HugeTLB机制：hugetlbfs文件系统<br>   (1) HugeTLB就是透过hugetlbfs方式向文件系统提供使用HugeTLB大页机制<br>   (2) hugetlbfs创建的文件可以被读系统调用操作，但不允许写系统调用操作，可以mmap映射</p>\n<h3 id=\"复合大页（Compound-pages）：多个page组合起来管理连续内存空间\"><a href=\"#复合大页（Compound-pages）：多个page组合起来管理连续内存空间\" class=\"headerlink\" title=\"复合大页（Compound pages）：多个page组合起来管理连续内存空间\"></a>复合大页（Compound pages）：多个page组合起来管理连续内存空间</h3><h3 id=\"透明大页（Transparent-Huge-Pages）：伙伴系统直接动态分配\"><a href=\"#透明大页（Transparent-Huge-Pages）：伙伴系统直接动态分配\" class=\"headerlink\" title=\"透明大页（Transparent Huge Pages）：伙伴系统直接动态分配\"></a>透明大页（Transparent Huge Pages）：伙伴系统直接动态分配</h3><p>   透明大页机制介绍：khugepaged线程</p>\n<ol>\n<li>Hash表是为了便于通过mm_struct指针地址，来找到对应的mm_slot结构</li>\n<li>Khugepaged_scan管理的链表是透明大页遍历扫描的链表，透明大页遍历每个mm_slot 的mm_struct</li>\n<li>通过mm_struct，遍历每个vma数据结构，扫描vma的地址空间，每次按2M大小扫描对应的pte内容<br>   透明大页由于性能抖动以及挂死等问题，被禁用：<br>   <a href=\"https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/\">https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/</a></li>\n</ol>\n<h2 id=\"配置使用大页内存\"><a href=\"#配置使用大页内存\" class=\"headerlink\" title=\"配置使用大页内存\"></a>配置使用大页内存</h2><h4 id=\"用户态使用大页\"><a href=\"#用户态使用大页\" class=\"headerlink\" title=\"用户态使用大页\"></a>用户态使用大页</h4><p>   用户态使用大页有以下几种方法：</p>\n<ul>\n<li>mount一个特殊的hugetlbfs文件系统，在上面创建文件，然后用mmap()进行访问, 但文件是只读的。也可以使用libhugetlbfs。</li>\n<li>shmget&#x2F;shmat，调用shmget申请共享内存加上SHM_HUGETLB标志。</li>\n<li>mmap()时指定MAAP_HUGETLB标志。</li>\n<li>memfd的memfd_create传MFD_HUGETLB标记</li>\n</ul>\n<h5 id=\"mmap方式使用示例\"><a href=\"#mmap方式使用示例\" class=\"headerlink\" title=\"mmap方式使用示例\"></a>mmap方式使用示例</h5><ol>\n<li>cat &#x2F;proc&#x2F;meminfo | grep -i huge查看大页预留情况<br>AnonHugePages:      2048 kB<br>HugePages_Total:     200<br>HugePages_Free:      200<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB</li>\n<li>预留大页（200个大页）<br>echo 200 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;nr_huagepages<br>或者<br>sysctl vm.nr_hugepages&#x3D;200</li>\n<li>mmap + memset的时候，在mmap参数中添加MAP_HUGETLB申请使用大页<br>例如：<br>(1) 申请使用大页<br>   size &#x3D; 2 * 1024 * 1024;<br>   addr &#x3D; mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | 0x40000 &#x2F;<em>MAP_HUGETLB</em>&#x2F;, -1, 0);<br>   memset(addr, 0, size);<br>(2) 重新查看大页使用情况<br>   AnonHugePages:      2048 kB<br>   HugePages_Total:     200<br>   HugePages_Free:      199<br>   HugePages_Rsvd:        0<br>   HugePages_Surp:        0<br>   Hugepagesize:       2048 kB</li>\n</ol>\n<h5 id=\"mount-hugetlbfs方式示例\"><a href=\"#mount-hugetlbfs方式示例\" class=\"headerlink\" title=\"mount hugetlbfs方式示例\"></a>mount hugetlbfs方式示例</h5><p>   libhugetlbfs：使用大页，将用户态程序的text&#x2F;data&#x2F;BSS保存到大页功能，提高性能</p>\n<h5 id=\"shmemget方式示例\"><a href=\"#shmemget方式示例\" class=\"headerlink\" title=\"shmemget方式示例\"></a>shmemget方式示例</h5><p>   shmem大页：<a href=\"https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux\">https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux</a></p>\n<h4 id=\"内核态申请大页\"><a href=\"#内核态申请大页\" class=\"headerlink\" title=\"内核态申请大页\"></a>内核态申请大页</h4>","cover":false,"excerpt":"","more":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/wangquan1992/article/details/103963108\">https://blog.csdn.net/wangquan1992/article/details/103963108</a><br><a href=\"https://blog.csdn.net/hbuxiaofei/article/details/128402495\">https://blog.csdn.net/hbuxiaofei/article/details/128402495</a><br><a href=\"https://blog.csdn.net/tony_vip/article/details/113791585\">https://blog.csdn.net/tony_vip/article/details/113791585</a></p>\n<p><a href=\"https://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf\">https://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf</a></p>\n<h2 id=\"为什么使用大页\"><a href=\"#为什么使用大页\" class=\"headerlink\" title=\"为什么使用大页\"></a>为什么使用大页</h2><h4 id=\"大页提高性能\"><a href=\"#大页提高性能\" class=\"headerlink\" title=\"大页提高性能\"></a>大页提高性能</h4><p>大页能提高性能的原理：MMU翻译页表，按照2MB翻译，到PMD这层就可以了，不用翻译到PTE阶段。</p>\n<h2 id=\"大页类型\"><a href=\"#大页类型\" class=\"headerlink\" title=\"大页类型\"></a>大页类型</h2><h3 id=\"HugeTLB机制：\"><a href=\"#HugeTLB机制：\" class=\"headerlink\" title=\"HugeTLB机制：\"></a>HugeTLB机制：</h3><p>   hstate管理大页，从伙伴系统申请，由order值决定大小。小于order的由伙伴系统申请，大于order的由memblock预留内存中申请或者调用alloc_cont_range申请。<br>   HugeTLB机制：hugetlbfs文件系统<br>   (1) HugeTLB就是透过hugetlbfs方式向文件系统提供使用HugeTLB大页机制<br>   (2) hugetlbfs创建的文件可以被读系统调用操作，但不允许写系统调用操作，可以mmap映射</p>\n<h3 id=\"复合大页（Compound-pages）：多个page组合起来管理连续内存空间\"><a href=\"#复合大页（Compound-pages）：多个page组合起来管理连续内存空间\" class=\"headerlink\" title=\"复合大页（Compound pages）：多个page组合起来管理连续内存空间\"></a>复合大页（Compound pages）：多个page组合起来管理连续内存空间</h3><h3 id=\"透明大页（Transparent-Huge-Pages）：伙伴系统直接动态分配\"><a href=\"#透明大页（Transparent-Huge-Pages）：伙伴系统直接动态分配\" class=\"headerlink\" title=\"透明大页（Transparent Huge Pages）：伙伴系统直接动态分配\"></a>透明大页（Transparent Huge Pages）：伙伴系统直接动态分配</h3><p>   透明大页机制介绍：khugepaged线程</p>\n<ol>\n<li>Hash表是为了便于通过mm_struct指针地址，来找到对应的mm_slot结构</li>\n<li>Khugepaged_scan管理的链表是透明大页遍历扫描的链表，透明大页遍历每个mm_slot 的mm_struct</li>\n<li>通过mm_struct，遍历每个vma数据结构，扫描vma的地址空间，每次按2M大小扫描对应的pte内容<br>   透明大页由于性能抖动以及挂死等问题，被禁用：<br>   <a href=\"https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/\">https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/</a></li>\n</ol>\n<h2 id=\"配置使用大页内存\"><a href=\"#配置使用大页内存\" class=\"headerlink\" title=\"配置使用大页内存\"></a>配置使用大页内存</h2><h4 id=\"用户态使用大页\"><a href=\"#用户态使用大页\" class=\"headerlink\" title=\"用户态使用大页\"></a>用户态使用大页</h4><p>   用户态使用大页有以下几种方法：</p>\n<ul>\n<li>mount一个特殊的hugetlbfs文件系统，在上面创建文件，然后用mmap()进行访问, 但文件是只读的。也可以使用libhugetlbfs。</li>\n<li>shmget&#x2F;shmat，调用shmget申请共享内存加上SHM_HUGETLB标志。</li>\n<li>mmap()时指定MAAP_HUGETLB标志。</li>\n<li>memfd的memfd_create传MFD_HUGETLB标记</li>\n</ul>\n<h5 id=\"mmap方式使用示例\"><a href=\"#mmap方式使用示例\" class=\"headerlink\" title=\"mmap方式使用示例\"></a>mmap方式使用示例</h5><ol>\n<li>cat &#x2F;proc&#x2F;meminfo | grep -i huge查看大页预留情况<br>AnonHugePages:      2048 kB<br>HugePages_Total:     200<br>HugePages_Free:      200<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB</li>\n<li>预留大页（200个大页）<br>echo 200 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;nr_huagepages<br>或者<br>sysctl vm.nr_hugepages&#x3D;200</li>\n<li>mmap + memset的时候，在mmap参数中添加MAP_HUGETLB申请使用大页<br>例如：<br>(1) 申请使用大页<br>   size &#x3D; 2 * 1024 * 1024;<br>   addr &#x3D; mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | 0x40000 &#x2F;<em>MAP_HUGETLB</em>&#x2F;, -1, 0);<br>   memset(addr, 0, size);<br>(2) 重新查看大页使用情况<br>   AnonHugePages:      2048 kB<br>   HugePages_Total:     200<br>   HugePages_Free:      199<br>   HugePages_Rsvd:        0<br>   HugePages_Surp:        0<br>   Hugepagesize:       2048 kB</li>\n</ol>\n<h5 id=\"mount-hugetlbfs方式示例\"><a href=\"#mount-hugetlbfs方式示例\" class=\"headerlink\" title=\"mount hugetlbfs方式示例\"></a>mount hugetlbfs方式示例</h5><p>   libhugetlbfs：使用大页，将用户态程序的text&#x2F;data&#x2F;BSS保存到大页功能，提高性能</p>\n<h5 id=\"shmemget方式示例\"><a href=\"#shmemget方式示例\" class=\"headerlink\" title=\"shmemget方式示例\"></a>shmemget方式示例</h5><p>   shmem大页：<a href=\"https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux\">https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux</a></p>\n<h4 id=\"内核态申请大页\"><a href=\"#内核态申请大页\" class=\"headerlink\" title=\"内核态申请大页\"></a>内核态申请大页</h4>"},{"title":"I2C协议","_content":"\n## I2C协议综述\nI2C总线包含两条线，SDA(串行数据线)/SDL(串行时钟线). 原理是通过SDA/SDL的电平高低的时序控制来进行数据的传递。\n在空闲状态时，这两个线一般被上面所接的上拉电阻拉高，保持高电平。\nI2C是半双工通信方式，同一时间只能单向通信。通信速度根据通信模式如下：\n(1) 标准模式：100Kbit/s\n(2) 快速模式：400Kbit/s\n(3) 高速模式：3.4Mbit/s。\n\n## I2C主设备/从设备\nI2C的是分主设备与从设备的。\n1) I2C通信时，通信设备之间的地位是平等的，分为主设备和从设备，其中主设备一个、从设备多个。主设备要主导整个通信过程，从设备根据I2C协议被动的响应主设备；\n2) 在I2C通信中，没有规定谁做主设备、谁做从设备，是通信双方自己协商的。一个设备在同一时间只能做主设备或者从设备，但是有的设备可以通过软件配置来决定在此次通信时做主设备还是从设备。\n\n## I2C总线\n### I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA/SDL电平高低，I2C总线状态可以分为如下几种：\n(1) SDA/SDL高电平：空闲\n(2) SDA由高变低，SDL高电平：开始信号\n(3) SDL由低变高：SDL高电平：结束信号\n\n### I2C总线状态转移：\n在开始条件产生后，总线出于忙状态，总线由数据传输的主从设备独占，其他I2C期间无法访问总线。\n在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次出于空闲状态。\n\n### I2C数据传输：\nI2C发送完开始信号之后，==主设备== 在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着==从设备==将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否定应答位。ACK信号就是从设备在拉低SDA之后，再给一个SDL脉冲？\n","source":"_posts/I2C Protocol.md","raw":"---\ntitle: I2C协议\n---\n\n## I2C协议综述\nI2C总线包含两条线，SDA(串行数据线)/SDL(串行时钟线). 原理是通过SDA/SDL的电平高低的时序控制来进行数据的传递。\n在空闲状态时，这两个线一般被上面所接的上拉电阻拉高，保持高电平。\nI2C是半双工通信方式，同一时间只能单向通信。通信速度根据通信模式如下：\n(1) 标准模式：100Kbit/s\n(2) 快速模式：400Kbit/s\n(3) 高速模式：3.4Mbit/s。\n\n## I2C主设备/从设备\nI2C的是分主设备与从设备的。\n1) I2C通信时，通信设备之间的地位是平等的，分为主设备和从设备，其中主设备一个、从设备多个。主设备要主导整个通信过程，从设备根据I2C协议被动的响应主设备；\n2) 在I2C通信中，没有规定谁做主设备、谁做从设备，是通信双方自己协商的。一个设备在同一时间只能做主设备或者从设备，但是有的设备可以通过软件配置来决定在此次通信时做主设备还是从设备。\n\n## I2C总线\n### I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA/SDL电平高低，I2C总线状态可以分为如下几种：\n(1) SDA/SDL高电平：空闲\n(2) SDA由高变低，SDL高电平：开始信号\n(3) SDL由低变高：SDL高电平：结束信号\n\n### I2C总线状态转移：\n在开始条件产生后，总线出于忙状态，总线由数据传输的主从设备独占，其他I2C期间无法访问总线。\n在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次出于空闲状态。\n\n### I2C数据传输：\nI2C发送完开始信号之后，==主设备== 在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着==从设备==将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否定应答位。ACK信号就是从设备在拉低SDA之后，再给一个SDL脉冲？\n","slug":"I2C Protocol","published":1,"date":"2024-08-09T10:53:15.489Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vv0005cbq2hfoh8pm9","content":"<h2 id=\"I2C协议综述\"><a href=\"#I2C协议综述\" class=\"headerlink\" title=\"I2C协议综述\"></a>I2C协议综述</h2><p>I2C总线包含两条线，SDA(串行数据线)&#x2F;SDL(串行时钟线). 原理是通过SDA&#x2F;SDL的电平高低的时序控制来进行数据的传递。<br>在空闲状态时，这两个线一般被上面所接的上拉电阻拉高，保持高电平。<br>I2C是半双工通信方式，同一时间只能单向通信。通信速度根据通信模式如下：<br>(1) 标准模式：100Kbit&#x2F;s<br>(2) 快速模式：400Kbit&#x2F;s<br>(3) 高速模式：3.4Mbit&#x2F;s。</p>\n<h2 id=\"I2C主设备-从设备\"><a href=\"#I2C主设备-从设备\" class=\"headerlink\" title=\"I2C主设备&#x2F;从设备\"></a>I2C主设备&#x2F;从设备</h2><p>I2C的是分主设备与从设备的。</p>\n<ol>\n<li>I2C通信时，通信设备之间的地位是平等的，分为主设备和从设备，其中主设备一个、从设备多个。主设备要主导整个通信过程，从设备根据I2C协议被动的响应主设备；</li>\n<li>在I2C通信中，没有规定谁做主设备、谁做从设备，是通信双方自己协商的。一个设备在同一时间只能做主设备或者从设备，但是有的设备可以通过软件配置来决定在此次通信时做主设备还是从设备。</li>\n</ol>\n<h2 id=\"I2C总线\"><a href=\"#I2C总线\" class=\"headerlink\" title=\"I2C总线\"></a>I2C总线</h2><h3 id=\"I2C总线状态：I2C数据传输单位是一个字节-8bit-，数据前后要有一个开始信号和结束信号。根据SDA-SDL电平高低，I2C总线状态可以分为如下几种：\"><a href=\"#I2C总线状态：I2C数据传输单位是一个字节-8bit-，数据前后要有一个开始信号和结束信号。根据SDA-SDL电平高低，I2C总线状态可以分为如下几种：\" class=\"headerlink\" title=\"I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA&#x2F;SDL电平高低，I2C总线状态可以分为如下几种：\"></a>I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA&#x2F;SDL电平高低，I2C总线状态可以分为如下几种：</h3><p>(1) SDA&#x2F;SDL高电平：空闲<br>(2) SDA由高变低，SDL高电平：开始信号<br>(3) SDL由低变高：SDL高电平：结束信号</p>\n<h3 id=\"I2C总线状态转移：\"><a href=\"#I2C总线状态转移：\" class=\"headerlink\" title=\"I2C总线状态转移：\"></a>I2C总线状态转移：</h3><p>在开始条件产生后，总线出于忙状态，总线由数据传输的主从设备独占，其他I2C期间无法访问总线。<br>在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次出于空闲状态。</p>\n<h3 id=\"I2C数据传输：\"><a href=\"#I2C数据传输：\" class=\"headerlink\" title=\"I2C数据传输：\"></a>I2C数据传输：</h3><p>I2C发送完开始信号之后，&#x3D;&#x3D;主设备&#x3D;&#x3D; 在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着&#x3D;&#x3D;从设备&#x3D;&#x3D;将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否定应答位。ACK信号就是从设备在拉低SDA之后，再给一个SDL脉冲？</p>\n","cover":false,"excerpt":"","more":"<h2 id=\"I2C协议综述\"><a href=\"#I2C协议综述\" class=\"headerlink\" title=\"I2C协议综述\"></a>I2C协议综述</h2><p>I2C总线包含两条线，SDA(串行数据线)&#x2F;SDL(串行时钟线). 原理是通过SDA&#x2F;SDL的电平高低的时序控制来进行数据的传递。<br>在空闲状态时，这两个线一般被上面所接的上拉电阻拉高，保持高电平。<br>I2C是半双工通信方式，同一时间只能单向通信。通信速度根据通信模式如下：<br>(1) 标准模式：100Kbit&#x2F;s<br>(2) 快速模式：400Kbit&#x2F;s<br>(3) 高速模式：3.4Mbit&#x2F;s。</p>\n<h2 id=\"I2C主设备-从设备\"><a href=\"#I2C主设备-从设备\" class=\"headerlink\" title=\"I2C主设备&#x2F;从设备\"></a>I2C主设备&#x2F;从设备</h2><p>I2C的是分主设备与从设备的。</p>\n<ol>\n<li>I2C通信时，通信设备之间的地位是平等的，分为主设备和从设备，其中主设备一个、从设备多个。主设备要主导整个通信过程，从设备根据I2C协议被动的响应主设备；</li>\n<li>在I2C通信中，没有规定谁做主设备、谁做从设备，是通信双方自己协商的。一个设备在同一时间只能做主设备或者从设备，但是有的设备可以通过软件配置来决定在此次通信时做主设备还是从设备。</li>\n</ol>\n<h2 id=\"I2C总线\"><a href=\"#I2C总线\" class=\"headerlink\" title=\"I2C总线\"></a>I2C总线</h2><h3 id=\"I2C总线状态：I2C数据传输单位是一个字节-8bit-，数据前后要有一个开始信号和结束信号。根据SDA-SDL电平高低，I2C总线状态可以分为如下几种：\"><a href=\"#I2C总线状态：I2C数据传输单位是一个字节-8bit-，数据前后要有一个开始信号和结束信号。根据SDA-SDL电平高低，I2C总线状态可以分为如下几种：\" class=\"headerlink\" title=\"I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA&#x2F;SDL电平高低，I2C总线状态可以分为如下几种：\"></a>I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA&#x2F;SDL电平高低，I2C总线状态可以分为如下几种：</h3><p>(1) SDA&#x2F;SDL高电平：空闲<br>(2) SDA由高变低，SDL高电平：开始信号<br>(3) SDL由低变高：SDL高电平：结束信号</p>\n<h3 id=\"I2C总线状态转移：\"><a href=\"#I2C总线状态转移：\" class=\"headerlink\" title=\"I2C总线状态转移：\"></a>I2C总线状态转移：</h3><p>在开始条件产生后，总线出于忙状态，总线由数据传输的主从设备独占，其他I2C期间无法访问总线。<br>在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次出于空闲状态。</p>\n<h3 id=\"I2C数据传输：\"><a href=\"#I2C数据传输：\" class=\"headerlink\" title=\"I2C数据传输：\"></a>I2C数据传输：</h3><p>I2C发送完开始信号之后，&#x3D;&#x3D;主设备&#x3D;&#x3D; 在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着&#x3D;&#x3D;从设备&#x3D;&#x3D;将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否定应答位。ACK信号就是从设备在拉低SDA之后，再给一个SDL脉冲？</p>\n"},{"title":"Kprobe","_content":"\n## 内核态注册\nhttps://docs.kernel.org/trace/kprobes.html\n\n## 用户态使用Kprobe探测内核函数\n### 开启关闭Kprobe\n1) 开启：echo 1 > /sys/kernel/debug/tracing/events/kprobes/enable\n2) 关闭：echo 0 > /sys/kernel/debug/tracing/events/kprobes/enable\n### 设置Kprobe探测点\n1) 返回值打印：\n  echo 'r 函数名 ret=$retval' > /sys/kernel/debug/tracing/kprobe_events\n2) 入参打印：\n  x86平台使用%ax, %bx, %cx, %dx表示第0~3个参数。arm平台使用x0, x1, x2, x3来表示第0~3个参数。Linux4.x版本之后，应该都可以使用arg0, arg1等方式表示。\n  (1) 函数的参数直接打印值：\n     X86打印第一个第二个参数:echo 'p function_name a=%ax:s32 b=%bx:u64' > /sys/kernel/debug/tracing/kprobe_events\n     ARM打印第一个第二个参数:echo 'p function_name a=%x0:x64 b=%x1' > /sys/kernel/debug/tracing/kprobe_events\n     这里参数:后面s32, u64, x64等都表示的是需要打印的类型。x64表示按照16禁止打印，数据位宽就是64bit（8字节）\n  (2) 函数参数是指针，打印指针里边的内容：\n    echo 'p function_name +0(%x1):x64 +8(%x1):x64 +16(%x1):x64' > /sys/kernel/debug/tracing/kprobe_events\n    +0(指针)表示解引用指针。按照上面的打印，第二个参数就是指针，+0(%x1):x64就是表示第二个参数指针偏移0并按照x64方式打印。\n### 查看结果\ncat /sys/kernel/debug/tracing/trace\n\n### 清空结果\necho > /sys/kernel/debug/tracing/trace\n\n### 查看调用栈\necho 1 > /sys/kernel/debug/tracing/options/stacktrace\n\n### 过滤入参\necho 'arg2==期望的值' > /sys/kernel/debug/tracing/events/kprobes/p_函数名_0/filter\n\n### 挂死打印\n当内核panic的时候ftrace_dump函数会将trace缓冲区里边的内容打印到内核日志中。\necho 1 > /proc/sys/kernel/ftrace_dump_on_oops\n例如：调用栈显示某个函数有挂死现象，则可以按照上述方式打开并跟踪参数情况，可以追踪哪些参数传到函数中导致的异常\n\n\n","source":"_posts/Kprobe.md","raw":"---\ntitle: Kprobe\n---\n\n## 内核态注册\nhttps://docs.kernel.org/trace/kprobes.html\n\n## 用户态使用Kprobe探测内核函数\n### 开启关闭Kprobe\n1) 开启：echo 1 > /sys/kernel/debug/tracing/events/kprobes/enable\n2) 关闭：echo 0 > /sys/kernel/debug/tracing/events/kprobes/enable\n### 设置Kprobe探测点\n1) 返回值打印：\n  echo 'r 函数名 ret=$retval' > /sys/kernel/debug/tracing/kprobe_events\n2) 入参打印：\n  x86平台使用%ax, %bx, %cx, %dx表示第0~3个参数。arm平台使用x0, x1, x2, x3来表示第0~3个参数。Linux4.x版本之后，应该都可以使用arg0, arg1等方式表示。\n  (1) 函数的参数直接打印值：\n     X86打印第一个第二个参数:echo 'p function_name a=%ax:s32 b=%bx:u64' > /sys/kernel/debug/tracing/kprobe_events\n     ARM打印第一个第二个参数:echo 'p function_name a=%x0:x64 b=%x1' > /sys/kernel/debug/tracing/kprobe_events\n     这里参数:后面s32, u64, x64等都表示的是需要打印的类型。x64表示按照16禁止打印，数据位宽就是64bit（8字节）\n  (2) 函数参数是指针，打印指针里边的内容：\n    echo 'p function_name +0(%x1):x64 +8(%x1):x64 +16(%x1):x64' > /sys/kernel/debug/tracing/kprobe_events\n    +0(指针)表示解引用指针。按照上面的打印，第二个参数就是指针，+0(%x1):x64就是表示第二个参数指针偏移0并按照x64方式打印。\n### 查看结果\ncat /sys/kernel/debug/tracing/trace\n\n### 清空结果\necho > /sys/kernel/debug/tracing/trace\n\n### 查看调用栈\necho 1 > /sys/kernel/debug/tracing/options/stacktrace\n\n### 过滤入参\necho 'arg2==期望的值' > /sys/kernel/debug/tracing/events/kprobes/p_函数名_0/filter\n\n### 挂死打印\n当内核panic的时候ftrace_dump函数会将trace缓冲区里边的内容打印到内核日志中。\necho 1 > /proc/sys/kernel/ftrace_dump_on_oops\n例如：调用栈显示某个函数有挂死现象，则可以按照上述方式打开并跟踪参数情况，可以追踪哪些参数传到函数中导致的异常\n\n\n","slug":"Kprobe","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vv0006cbq2138d4l6i","content":"<h2 id=\"内核态注册\"><a href=\"#内核态注册\" class=\"headerlink\" title=\"内核态注册\"></a>内核态注册</h2><p><a href=\"https://docs.kernel.org/trace/kprobes.html\">https://docs.kernel.org/trace/kprobes.html</a></p>\n<h2 id=\"用户态使用Kprobe探测内核函数\"><a href=\"#用户态使用Kprobe探测内核函数\" class=\"headerlink\" title=\"用户态使用Kprobe探测内核函数\"></a>用户态使用Kprobe探测内核函数</h2><h3 id=\"开启关闭Kprobe\"><a href=\"#开启关闭Kprobe\" class=\"headerlink\" title=\"开启关闭Kprobe\"></a>开启关闭Kprobe</h3><ol>\n<li>开启：echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable</li>\n<li>关闭：echo 0 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable</li>\n</ol>\n<h3 id=\"设置Kprobe探测点\"><a href=\"#设置Kprobe探测点\" class=\"headerlink\" title=\"设置Kprobe探测点\"></a>设置Kprobe探测点</h3><ol>\n<li>返回值打印：<br>  echo ‘r 函数名 ret&#x3D;$retval’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events</li>\n<li>入参打印：<br>  x86平台使用%ax, %bx, %cx, %dx表示第0<del>3个参数。arm平台使用x0, x1, x2, x3来表示第0</del>3个参数。Linux4.x版本之后，应该都可以使用arg0, arg1等方式表示。<br>  (1) 函数的参数直接打印值：<br>  X86打印第一个第二个参数:echo ‘p function_name a&#x3D;%ax:s32 b&#x3D;%bx:u64’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events<br>  ARM打印第一个第二个参数:echo ‘p function_name a&#x3D;%x0:x64 b&#x3D;%x1’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events<br>  这里参数:后面s32, u64, x64等都表示的是需要打印的类型。x64表示按照16禁止打印，数据位宽就是64bit（8字节）<br>  (2) 函数参数是指针，打印指针里边的内容：<br> echo ‘p function_name +0(%x1):x64 +8(%x1):x64 +16(%x1):x64’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events<br> +0(指针)表示解引用指针。按照上面的打印，第二个参数就是指针，+0(%x1):x64就是表示第二个参数指针偏移0并按照x64方式打印。</li>\n</ol>\n<h3 id=\"查看结果\"><a href=\"#查看结果\" class=\"headerlink\" title=\"查看结果\"></a>查看结果</h3><p>cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace</p>\n<h3 id=\"清空结果\"><a href=\"#清空结果\" class=\"headerlink\" title=\"清空结果\"></a>清空结果</h3><p>echo &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace</p>\n<h3 id=\"查看调用栈\"><a href=\"#查看调用栈\" class=\"headerlink\" title=\"查看调用栈\"></a>查看调用栈</h3><p>echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;options&#x2F;stacktrace</p>\n<h3 id=\"过滤入参\"><a href=\"#过滤入参\" class=\"headerlink\" title=\"过滤入参\"></a>过滤入参</h3><p>echo ‘arg2&#x3D;&#x3D;期望的值’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;p_函数名_0&#x2F;filter</p>\n<h3 id=\"挂死打印\"><a href=\"#挂死打印\" class=\"headerlink\" title=\"挂死打印\"></a>挂死打印</h3><p>当内核panic的时候ftrace_dump函数会将trace缓冲区里边的内容打印到内核日志中。<br>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;ftrace_dump_on_oops<br>例如：调用栈显示某个函数有挂死现象，则可以按照上述方式打开并跟踪参数情况，可以追踪哪些参数传到函数中导致的异常</p>\n","cover":false,"excerpt":"","more":"<h2 id=\"内核态注册\"><a href=\"#内核态注册\" class=\"headerlink\" title=\"内核态注册\"></a>内核态注册</h2><p><a href=\"https://docs.kernel.org/trace/kprobes.html\">https://docs.kernel.org/trace/kprobes.html</a></p>\n<h2 id=\"用户态使用Kprobe探测内核函数\"><a href=\"#用户态使用Kprobe探测内核函数\" class=\"headerlink\" title=\"用户态使用Kprobe探测内核函数\"></a>用户态使用Kprobe探测内核函数</h2><h3 id=\"开启关闭Kprobe\"><a href=\"#开启关闭Kprobe\" class=\"headerlink\" title=\"开启关闭Kprobe\"></a>开启关闭Kprobe</h3><ol>\n<li>开启：echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable</li>\n<li>关闭：echo 0 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable</li>\n</ol>\n<h3 id=\"设置Kprobe探测点\"><a href=\"#设置Kprobe探测点\" class=\"headerlink\" title=\"设置Kprobe探测点\"></a>设置Kprobe探测点</h3><ol>\n<li>返回值打印：<br>  echo ‘r 函数名 ret&#x3D;$retval’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events</li>\n<li>入参打印：<br>  x86平台使用%ax, %bx, %cx, %dx表示第0<del>3个参数。arm平台使用x0, x1, x2, x3来表示第0</del>3个参数。Linux4.x版本之后，应该都可以使用arg0, arg1等方式表示。<br>  (1) 函数的参数直接打印值：<br>  X86打印第一个第二个参数:echo ‘p function_name a&#x3D;%ax:s32 b&#x3D;%bx:u64’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events<br>  ARM打印第一个第二个参数:echo ‘p function_name a&#x3D;%x0:x64 b&#x3D;%x1’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events<br>  这里参数:后面s32, u64, x64等都表示的是需要打印的类型。x64表示按照16禁止打印，数据位宽就是64bit（8字节）<br>  (2) 函数参数是指针，打印指针里边的内容：<br> echo ‘p function_name +0(%x1):x64 +8(%x1):x64 +16(%x1):x64’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;kprobe_events<br> +0(指针)表示解引用指针。按照上面的打印，第二个参数就是指针，+0(%x1):x64就是表示第二个参数指针偏移0并按照x64方式打印。</li>\n</ol>\n<h3 id=\"查看结果\"><a href=\"#查看结果\" class=\"headerlink\" title=\"查看结果\"></a>查看结果</h3><p>cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace</p>\n<h3 id=\"清空结果\"><a href=\"#清空结果\" class=\"headerlink\" title=\"清空结果\"></a>清空结果</h3><p>echo &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace</p>\n<h3 id=\"查看调用栈\"><a href=\"#查看调用栈\" class=\"headerlink\" title=\"查看调用栈\"></a>查看调用栈</h3><p>echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;options&#x2F;stacktrace</p>\n<h3 id=\"过滤入参\"><a href=\"#过滤入参\" class=\"headerlink\" title=\"过滤入参\"></a>过滤入参</h3><p>echo ‘arg2&#x3D;&#x3D;期望的值’ &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;p_函数名_0&#x2F;filter</p>\n<h3 id=\"挂死打印\"><a href=\"#挂死打印\" class=\"headerlink\" title=\"挂死打印\"></a>挂死打印</h3><p>当内核panic的时候ftrace_dump函数会将trace缓冲区里边的内容打印到内核日志中。<br>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;ftrace_dump_on_oops<br>例如：调用栈显示某个函数有挂死现象，则可以按照上述方式打开并跟踪参数情况，可以追踪哪些参数传到函数中导致的异常</p>\n"},{"_content":"\n","source":"_posts/Kvm.md","raw":"\n","slug":"Kvm","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vw0007cbq213soh0f0","content":"","cover":false,"excerpt":"","more":""},{"title":"Rcu (Read Copy Update)","_content":"\n## 参考\nhttps://zhuanlan.zhihu.com/p/30583695\nhttp://www.wowotech.net/kernel_synchronization/rcu_fundamentals.html\nhttp://3ms.huawei.com/km/blogs/details/12175655\n\nhttp://3ms.huawei.com/km/blogs/details/5886747\nhttps://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit\n\nhttp://3ms.huawei.com/km/blogs/details/125081\n\n例子：\nhttps://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c\n","source":"_posts/Rcu.md","raw":"---\ntitle: Rcu (Read Copy Update)\n---\n\n## 参考\nhttps://zhuanlan.zhihu.com/p/30583695\nhttp://www.wowotech.net/kernel_synchronization/rcu_fundamentals.html\nhttp://3ms.huawei.com/km/blogs/details/12175655\n\nhttp://3ms.huawei.com/km/blogs/details/5886747\nhttps://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit\n\nhttp://3ms.huawei.com/km/blogs/details/125081\n\n例子：\nhttps://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c\n","slug":"Rcu","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vw0008cbq21xki3uqy","content":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/30583695\">https://zhuanlan.zhihu.com/p/30583695</a><br><a href=\"http://www.wowotech.net/kernel_synchronization/rcu_fundamentals.html\">http://www.wowotech.net/kernel_synchronization/rcu_fundamentals.html</a><br><a href=\"http://3ms.huawei.com/km/blogs/details/12175655\">http://3ms.huawei.com/km/blogs/details/12175655</a></p>\n<p><a href=\"http://3ms.huawei.com/km/blogs/details/5886747\">http://3ms.huawei.com/km/blogs/details/5886747</a><br><a href=\"https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit\">https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit</a></p>\n<p><a href=\"http://3ms.huawei.com/km/blogs/details/125081\">http://3ms.huawei.com/km/blogs/details/125081</a></p>\n<p>例子：<br><a href=\"https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c\">https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c</a></p>\n","cover":false,"excerpt":"","more":"<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/30583695\">https://zhuanlan.zhihu.com/p/30583695</a><br><a href=\"http://www.wowotech.net/kernel_synchronization/rcu_fundamentals.html\">http://www.wowotech.net/kernel_synchronization/rcu_fundamentals.html</a><br><a href=\"http://3ms.huawei.com/km/blogs/details/12175655\">http://3ms.huawei.com/km/blogs/details/12175655</a></p>\n<p><a href=\"http://3ms.huawei.com/km/blogs/details/5886747\">http://3ms.huawei.com/km/blogs/details/5886747</a><br><a href=\"https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit\">https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit</a></p>\n<p><a href=\"http://3ms.huawei.com/km/blogs/details/125081\">http://3ms.huawei.com/km/blogs/details/125081</a></p>\n<p>例子：<br><a href=\"https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c\">https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c</a></p>\n"},{"title":"页表管理","_content":"\n## TLB\n### TLB介绍\nTLB是一个cache、是保存MMU最近转换过的内容(TLB hit)。在每次MMU地址转换的时候、都会先\n查看TLB中是否存在、如果有的话就可以直接访问。如果TLB中没有(TLB miss)、就会通过MMU做\n转换并保存在TLB中。TLB中不仅保存虚拟地址和对应的物理地址、也保存\n1)\tattributes such as memory type (见memory ordering)\n2)\tcache policies\n3)\taccess permissions \n4)\tthe Address Space ID (ASID), and the Virtual Machine ID (VMID)。\n\n如果MMU页表在建立之后、中途需要调整变化、在修改完MMU对应的页表之后、就要刷新(invalidate)TLB。\n\n### TLB刷新\nTLBI命令就是负责刷新TLB。\n\nTLBI <type><level>{IS} {, <Xt>}\n\ntype字段：\nALL：刷新所有TLB entry\nVMALL: 刷新所有stage 1TLB entry\n\n## MMU\n### MMU寄存器\n#### TCR(Translation Control Register)寄存器（包含TCR_EL1/TCR_EL2/TCR_EL3这几种）(D8-2038)\n\n##### TCR寄存器位分配\n\n###### T1SZ/T0SZ\n表示TTBR0_ELx能表示的地址范围，地址范围的计算公式就是2^(64-T1SZ) Bytest:\n例如：如果用户态地址范围是48位虚拟地址，那这里应该配置T0SZ=64-48=16, 虚拟地址的范围是 2^(64-16) = 0 ~ 0x0000_FFFF_FFFF_FFFF\n\n#### TTBR(Translation Table Base Register)寄存器\n##### TTBR0_EL1, TTBR1_EL1寄存器\n###### TTBR寄存器介绍\nStage1的页表翻译时，MMU页表的基地址由TTBR0_EL1, TTBR1_EL1指定。TTBR0_EL1指定用户态页表基地址，TTBR1_EL1指定内核态的页表基地址。\nEL2和EL3有TTBR0但没有TTBR1(就是说EL2有TTBR0_EL2, EL3有TTBR_EL3，但没有TTBR1_EL2和TTRB1_EL3)。\n- EL2/EL3如果是aarch64, 也只能使用0x0-0x0000FFFF_FFFFFFFF范围的地址（对地址范围有疑问看下一节TTBR地址范围确定一节）。\n用户态不能直接访问MMU，当然也没有所谓的TTBR0_EL0，TTBR1_EL0之类的寄存器了。\n\n###### TTBR地址范围确定\n\n![Alt text](./TTBR0-TTBR1地址范围和选择.drawio.svg)\n<img src=\"./TTBR0-TTBR1地址范围和选择.drawio.svg\">\n\n###### 如何选择（D5-1736）\n\n###### TTBR位分配\n\n1) ASID是做什么？\n\n\n##### VTTBR_EL2\n\n## 页表设置\n\n\n保存stage2的页表基地址\n\nPTE_SHARED\n\npgprot_val（PAGE_KERNEL）\n\npteval_t\n\n这些都有什么不同\n\n\n\n## 页表walk\n\nhttps://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md\n\nhttps://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235^v43^pc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3\n\nhttps://blog.csdn.net/weixin_42135087/article/details/109057232\n\n\n","source":"_posts/MMU.md","raw":"---\ntitle: 页表管理\n---\n\n## TLB\n### TLB介绍\nTLB是一个cache、是保存MMU最近转换过的内容(TLB hit)。在每次MMU地址转换的时候、都会先\n查看TLB中是否存在、如果有的话就可以直接访问。如果TLB中没有(TLB miss)、就会通过MMU做\n转换并保存在TLB中。TLB中不仅保存虚拟地址和对应的物理地址、也保存\n1)\tattributes such as memory type (见memory ordering)\n2)\tcache policies\n3)\taccess permissions \n4)\tthe Address Space ID (ASID), and the Virtual Machine ID (VMID)。\n\n如果MMU页表在建立之后、中途需要调整变化、在修改完MMU对应的页表之后、就要刷新(invalidate)TLB。\n\n### TLB刷新\nTLBI命令就是负责刷新TLB。\n\nTLBI <type><level>{IS} {, <Xt>}\n\ntype字段：\nALL：刷新所有TLB entry\nVMALL: 刷新所有stage 1TLB entry\n\n## MMU\n### MMU寄存器\n#### TCR(Translation Control Register)寄存器（包含TCR_EL1/TCR_EL2/TCR_EL3这几种）(D8-2038)\n\n##### TCR寄存器位分配\n\n###### T1SZ/T0SZ\n表示TTBR0_ELx能表示的地址范围，地址范围的计算公式就是2^(64-T1SZ) Bytest:\n例如：如果用户态地址范围是48位虚拟地址，那这里应该配置T0SZ=64-48=16, 虚拟地址的范围是 2^(64-16) = 0 ~ 0x0000_FFFF_FFFF_FFFF\n\n#### TTBR(Translation Table Base Register)寄存器\n##### TTBR0_EL1, TTBR1_EL1寄存器\n###### TTBR寄存器介绍\nStage1的页表翻译时，MMU页表的基地址由TTBR0_EL1, TTBR1_EL1指定。TTBR0_EL1指定用户态页表基地址，TTBR1_EL1指定内核态的页表基地址。\nEL2和EL3有TTBR0但没有TTBR1(就是说EL2有TTBR0_EL2, EL3有TTBR_EL3，但没有TTBR1_EL2和TTRB1_EL3)。\n- EL2/EL3如果是aarch64, 也只能使用0x0-0x0000FFFF_FFFFFFFF范围的地址（对地址范围有疑问看下一节TTBR地址范围确定一节）。\n用户态不能直接访问MMU，当然也没有所谓的TTBR0_EL0，TTBR1_EL0之类的寄存器了。\n\n###### TTBR地址范围确定\n\n![Alt text](./TTBR0-TTBR1地址范围和选择.drawio.svg)\n<img src=\"./TTBR0-TTBR1地址范围和选择.drawio.svg\">\n\n###### 如何选择（D5-1736）\n\n###### TTBR位分配\n\n1) ASID是做什么？\n\n\n##### VTTBR_EL2\n\n## 页表设置\n\n\n保存stage2的页表基地址\n\nPTE_SHARED\n\npgprot_val（PAGE_KERNEL）\n\npteval_t\n\n这些都有什么不同\n\n\n\n## 页表walk\n\nhttps://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md\n\nhttps://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235^v43^pc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3\n\nhttps://blog.csdn.net/weixin_42135087/article/details/109057232\n\n\n","slug":"MMU","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vw0009cbq21iysfvqx","content":"<h2 id=\"TLB\"><a href=\"#TLB\" class=\"headerlink\" title=\"TLB\"></a>TLB</h2><h3 id=\"TLB介绍\"><a href=\"#TLB介绍\" class=\"headerlink\" title=\"TLB介绍\"></a>TLB介绍</h3><p>TLB是一个cache、是保存MMU最近转换过的内容(TLB hit)。在每次MMU地址转换的时候、都会先<br>查看TLB中是否存在、如果有的话就可以直接访问。如果TLB中没有(TLB miss)、就会通过MMU做<br>转换并保存在TLB中。TLB中不仅保存虚拟地址和对应的物理地址、也保存<br>1)\tattributes such as memory type (见memory ordering)<br>2)\tcache policies<br>3)\taccess permissions<br>4)\tthe Address Space ID (ASID), and the Virtual Machine ID (VMID)。</p>\n<p>如果MMU页表在建立之后、中途需要调整变化、在修改完MMU对应的页表之后、就要刷新(invalidate)TLB。</p>\n<h3 id=\"TLB刷新\"><a href=\"#TLB刷新\" class=\"headerlink\" title=\"TLB刷新\"></a>TLB刷新</h3><p>TLBI命令就是负责刷新TLB。</p>\n<p>TLBI <type><level>{IS} {, <Xt>}</p>\n<p>type字段：<br>ALL：刷新所有TLB entry<br>VMALL: 刷新所有stage 1TLB entry</p>\n<h2 id=\"MMU\"><a href=\"#MMU\" class=\"headerlink\" title=\"MMU\"></a>MMU</h2><h3 id=\"MMU寄存器\"><a href=\"#MMU寄存器\" class=\"headerlink\" title=\"MMU寄存器\"></a>MMU寄存器</h3><h4 id=\"TCR-Translation-Control-Register-寄存器（包含TCR-EL1-TCR-EL2-TCR-EL3这几种）-D8-2038\"><a href=\"#TCR-Translation-Control-Register-寄存器（包含TCR-EL1-TCR-EL2-TCR-EL3这几种）-D8-2038\" class=\"headerlink\" title=\"TCR(Translation Control Register)寄存器（包含TCR_EL1&#x2F;TCR_EL2&#x2F;TCR_EL3这几种）(D8-2038)\"></a>TCR(Translation Control Register)寄存器（包含TCR_EL1&#x2F;TCR_EL2&#x2F;TCR_EL3这几种）(D8-2038)</h4><h5 id=\"TCR寄存器位分配\"><a href=\"#TCR寄存器位分配\" class=\"headerlink\" title=\"TCR寄存器位分配\"></a>TCR寄存器位分配</h5><h6 id=\"T1SZ-T0SZ\"><a href=\"#T1SZ-T0SZ\" class=\"headerlink\" title=\"T1SZ&#x2F;T0SZ\"></a>T1SZ&#x2F;T0SZ</h6><p>表示TTBR0_ELx能表示的地址范围，地址范围的计算公式就是2^(64-T1SZ) Bytest:<br>例如：如果用户态地址范围是48位虚拟地址，那这里应该配置T0SZ&#x3D;64-48&#x3D;16, 虚拟地址的范围是 2^(64-16) &#x3D; 0 ~ 0x0000_FFFF_FFFF_FFFF</p>\n<h4 id=\"TTBR-Translation-Table-Base-Register-寄存器\"><a href=\"#TTBR-Translation-Table-Base-Register-寄存器\" class=\"headerlink\" title=\"TTBR(Translation Table Base Register)寄存器\"></a>TTBR(Translation Table Base Register)寄存器</h4><h5 id=\"TTBR0-EL1-TTBR1-EL1寄存器\"><a href=\"#TTBR0-EL1-TTBR1-EL1寄存器\" class=\"headerlink\" title=\"TTBR0_EL1, TTBR1_EL1寄存器\"></a>TTBR0_EL1, TTBR1_EL1寄存器</h5><h6 id=\"TTBR寄存器介绍\"><a href=\"#TTBR寄存器介绍\" class=\"headerlink\" title=\"TTBR寄存器介绍\"></a>TTBR寄存器介绍</h6><p>Stage1的页表翻译时，MMU页表的基地址由TTBR0_EL1, TTBR1_EL1指定。TTBR0_EL1指定用户态页表基地址，TTBR1_EL1指定内核态的页表基地址。<br>EL2和EL3有TTBR0但没有TTBR1(就是说EL2有TTBR0_EL2, EL3有TTBR_EL3，但没有TTBR1_EL2和TTRB1_EL3)。</p>\n<ul>\n<li>EL2&#x2F;EL3如果是aarch64, 也只能使用0x0-0x0000FFFF_FFFFFFFF范围的地址（对地址范围有疑问看下一节TTBR地址范围确定一节）。<br>用户态不能直接访问MMU，当然也没有所谓的TTBR0_EL0，TTBR1_EL0之类的寄存器了。</li>\n</ul>\n<h6 id=\"TTBR地址范围确定\"><a href=\"#TTBR地址范围确定\" class=\"headerlink\" title=\"TTBR地址范围确定\"></a>TTBR地址范围确定</h6><p><img src=\"/./TTBR0-TTBR1%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4%E5%92%8C%E9%80%89%E6%8B%A9.drawio.svg\" alt=\"Alt text\"><br><img src=\"./TTBR0-TTBR1地址范围和选择.drawio.svg\"></p>\n<h6 id=\"如何选择（D5-1736）\"><a href=\"#如何选择（D5-1736）\" class=\"headerlink\" title=\"如何选择（D5-1736）\"></a>如何选择（D5-1736）</h6><h6 id=\"TTBR位分配\"><a href=\"#TTBR位分配\" class=\"headerlink\" title=\"TTBR位分配\"></a>TTBR位分配</h6><ol>\n<li>ASID是做什么？</li>\n</ol>\n<h5 id=\"VTTBR-EL2\"><a href=\"#VTTBR-EL2\" class=\"headerlink\" title=\"VTTBR_EL2\"></a>VTTBR_EL2</h5><h2 id=\"页表设置\"><a href=\"#页表设置\" class=\"headerlink\" title=\"页表设置\"></a>页表设置</h2><p>保存stage2的页表基地址</p>\n<p>PTE_SHARED</p>\n<p>pgprot_val（PAGE_KERNEL）</p>\n<p>pteval_t</p>\n<p>这些都有什么不同</p>\n<h2 id=\"页表walk\"><a href=\"#页表walk\" class=\"headerlink\" title=\"页表walk\"></a>页表walk</h2><p><a href=\"https://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md\">https://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md</a></p>\n<p><a href=\"https://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235%5Ev43%5Epc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3\">https://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235^v43^pc_blog_bottom_relevance_base1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_42135087/article/details/109057232\">https://blog.csdn.net/weixin_42135087/article/details/109057232</a></p>\n","cover":false,"excerpt":"","more":"<h2 id=\"TLB\"><a href=\"#TLB\" class=\"headerlink\" title=\"TLB\"></a>TLB</h2><h3 id=\"TLB介绍\"><a href=\"#TLB介绍\" class=\"headerlink\" title=\"TLB介绍\"></a>TLB介绍</h3><p>TLB是一个cache、是保存MMU最近转换过的内容(TLB hit)。在每次MMU地址转换的时候、都会先<br>查看TLB中是否存在、如果有的话就可以直接访问。如果TLB中没有(TLB miss)、就会通过MMU做<br>转换并保存在TLB中。TLB中不仅保存虚拟地址和对应的物理地址、也保存<br>1)\tattributes such as memory type (见memory ordering)<br>2)\tcache policies<br>3)\taccess permissions<br>4)\tthe Address Space ID (ASID), and the Virtual Machine ID (VMID)。</p>\n<p>如果MMU页表在建立之后、中途需要调整变化、在修改完MMU对应的页表之后、就要刷新(invalidate)TLB。</p>\n<h3 id=\"TLB刷新\"><a href=\"#TLB刷新\" class=\"headerlink\" title=\"TLB刷新\"></a>TLB刷新</h3><p>TLBI命令就是负责刷新TLB。</p>\n<p>TLBI <type><level>{IS} {, <Xt>}</p>\n<p>type字段：<br>ALL：刷新所有TLB entry<br>VMALL: 刷新所有stage 1TLB entry</p>\n<h2 id=\"MMU\"><a href=\"#MMU\" class=\"headerlink\" title=\"MMU\"></a>MMU</h2><h3 id=\"MMU寄存器\"><a href=\"#MMU寄存器\" class=\"headerlink\" title=\"MMU寄存器\"></a>MMU寄存器</h3><h4 id=\"TCR-Translation-Control-Register-寄存器（包含TCR-EL1-TCR-EL2-TCR-EL3这几种）-D8-2038\"><a href=\"#TCR-Translation-Control-Register-寄存器（包含TCR-EL1-TCR-EL2-TCR-EL3这几种）-D8-2038\" class=\"headerlink\" title=\"TCR(Translation Control Register)寄存器（包含TCR_EL1&#x2F;TCR_EL2&#x2F;TCR_EL3这几种）(D8-2038)\"></a>TCR(Translation Control Register)寄存器（包含TCR_EL1&#x2F;TCR_EL2&#x2F;TCR_EL3这几种）(D8-2038)</h4><h5 id=\"TCR寄存器位分配\"><a href=\"#TCR寄存器位分配\" class=\"headerlink\" title=\"TCR寄存器位分配\"></a>TCR寄存器位分配</h5><h6 id=\"T1SZ-T0SZ\"><a href=\"#T1SZ-T0SZ\" class=\"headerlink\" title=\"T1SZ&#x2F;T0SZ\"></a>T1SZ&#x2F;T0SZ</h6><p>表示TTBR0_ELx能表示的地址范围，地址范围的计算公式就是2^(64-T1SZ) Bytest:<br>例如：如果用户态地址范围是48位虚拟地址，那这里应该配置T0SZ&#x3D;64-48&#x3D;16, 虚拟地址的范围是 2^(64-16) &#x3D; 0 ~ 0x0000_FFFF_FFFF_FFFF</p>\n<h4 id=\"TTBR-Translation-Table-Base-Register-寄存器\"><a href=\"#TTBR-Translation-Table-Base-Register-寄存器\" class=\"headerlink\" title=\"TTBR(Translation Table Base Register)寄存器\"></a>TTBR(Translation Table Base Register)寄存器</h4><h5 id=\"TTBR0-EL1-TTBR1-EL1寄存器\"><a href=\"#TTBR0-EL1-TTBR1-EL1寄存器\" class=\"headerlink\" title=\"TTBR0_EL1, TTBR1_EL1寄存器\"></a>TTBR0_EL1, TTBR1_EL1寄存器</h5><h6 id=\"TTBR寄存器介绍\"><a href=\"#TTBR寄存器介绍\" class=\"headerlink\" title=\"TTBR寄存器介绍\"></a>TTBR寄存器介绍</h6><p>Stage1的页表翻译时，MMU页表的基地址由TTBR0_EL1, TTBR1_EL1指定。TTBR0_EL1指定用户态页表基地址，TTBR1_EL1指定内核态的页表基地址。<br>EL2和EL3有TTBR0但没有TTBR1(就是说EL2有TTBR0_EL2, EL3有TTBR_EL3，但没有TTBR1_EL2和TTRB1_EL3)。</p>\n<ul>\n<li>EL2&#x2F;EL3如果是aarch64, 也只能使用0x0-0x0000FFFF_FFFFFFFF范围的地址（对地址范围有疑问看下一节TTBR地址范围确定一节）。<br>用户态不能直接访问MMU，当然也没有所谓的TTBR0_EL0，TTBR1_EL0之类的寄存器了。</li>\n</ul>\n<h6 id=\"TTBR地址范围确定\"><a href=\"#TTBR地址范围确定\" class=\"headerlink\" title=\"TTBR地址范围确定\"></a>TTBR地址范围确定</h6><p><img src=\"/./TTBR0-TTBR1%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4%E5%92%8C%E9%80%89%E6%8B%A9.drawio.svg\" alt=\"Alt text\"><br><img src=\"./TTBR0-TTBR1地址范围和选择.drawio.svg\"></p>\n<h6 id=\"如何选择（D5-1736）\"><a href=\"#如何选择（D5-1736）\" class=\"headerlink\" title=\"如何选择（D5-1736）\"></a>如何选择（D5-1736）</h6><h6 id=\"TTBR位分配\"><a href=\"#TTBR位分配\" class=\"headerlink\" title=\"TTBR位分配\"></a>TTBR位分配</h6><ol>\n<li>ASID是做什么？</li>\n</ol>\n<h5 id=\"VTTBR-EL2\"><a href=\"#VTTBR-EL2\" class=\"headerlink\" title=\"VTTBR_EL2\"></a>VTTBR_EL2</h5><h2 id=\"页表设置\"><a href=\"#页表设置\" class=\"headerlink\" title=\"页表设置\"></a>页表设置</h2><p>保存stage2的页表基地址</p>\n<p>PTE_SHARED</p>\n<p>pgprot_val（PAGE_KERNEL）</p>\n<p>pteval_t</p>\n<p>这些都有什么不同</p>\n<h2 id=\"页表walk\"><a href=\"#页表walk\" class=\"headerlink\" title=\"页表walk\"></a>页表walk</h2><p><a href=\"https://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md\">https://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md</a></p>\n<p><a href=\"https://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235%5Ev43%5Epc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3\">https://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235^v43^pc_blog_bottom_relevance_base1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_42135087/article/details/109057232\">https://blog.csdn.net/weixin_42135087/article/details/109057232</a></p>\n"},{"title":"Spinlock","_content":"","source":"_posts/Spinlock.md","raw":"---\ntitle: Spinlock\n---\n","slug":"Spinlock","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vw000acbq2h2fpcjsc","content":"","cover":false,"excerpt":"","more":""},{"title":"Tasklet","_content":"\n## Tasklet执行方式\n大概有一些同学对tasklet的串行化还有点困惑，其实在单处理器上最好理解，所以本帖主要讨论多处理器上tasklet如何实现串行化：同一个tasklet对象同一时刻只能在一个处理器上运行。\n\n在驱动程序中，tasklet是作为一种softirq形式出现的，所以对tasklet对象的提交一般发生在中断处理例程ISR中。一般一个tasklet用来对同一种中断类型进行后续的处理，所以完全不必要通过动态生成tasklet对象的方式在每次中断到来时重新生成一个tasklet对象来做后半段的处理。事实上Linux内核源码中，几乎所有的tasklet对象都是针对同一类型的中断只产生一个。如果有同学发现有例外的情况，请告诉我，将非常感谢。\n\n假设某个中断发生，由CPU0来处理，在它的ISR中会调用tasklet_schedule来提交一个tasklet对象，假设为tasklet_obj，那么tasklet_schedule首先会为该tasklet对象tasklet_obj.state打上一个标志：TASKLET_STATE_SCHED，表明该tasklet对象被提交但还没有被运行，前述的打标志的操作是个原子，代码里是test_and_set_bit，这意味着如果同时有处理器CPU0和CPU1都来提交该tasklet_obj，那么只有一个会被成功提交，不过不用担心一个tasklet对象没被提交成功的话会有啥副作用，因为在softirq的处理阶段，一个tasklet对象上的处理函数可以一并处理掉外设若干次同一中断要做的事，最典型的，比如网卡连续接收到两个数据包，产生两个中断到两个不同处理器上，因为只有一个tasklet对象被提交，当该对象上的延迟函数被执行时，它会将两个数据包都读到系统内存中。\n \nTASKLET_STATE_SCHED标志是确保tasklet串行化的第一道防线，但是如果该tasklet_obj对象已经被调度到处理器CPU0上运行了，那么TASKLET_STATE_SCHED标志会被清除，这意味着当一个tasklet_obj对象正在一个处理器上运行时，同一个tasklet_obj对象完全可以被提交到另一个处理器，比如CPU1上。那么这种情况下如何确保tasklet串行化呢，答案是tasklet_obj.state上为SMP系统增加的另一个标志位TASKLET_STATE_RUN，当一个tasklet_obj对象被某一处理器开始调度运行时，tasklet_action，也就是对应的softirq处理例程会通过tasklet_trylock来将该tasklet_obj对象的state成员打上标志TASKLET_STATE_RUN，这个操作同样是原子的，因此只会有一个处理器成功完成测试及打标志的动作，没成功的那个处理器上的tasklet_action会把当前的tasklet_obj重新加入到其所管理的tasklet_vec链表的尾部(因为一个相同的tasklet_obj对象已经在运行了，所以再期望其一并完成当前tasklet_obj所表示的任务变得不再可靠，这不同于刚提交时的情形，所以内核对此的策略是，把当前希望运行但是发现已经有同一个tasklet_obj对象的延迟函数正在被执行时，将当前对象加入到处理器tasklet_vec的链表尾部)。那先前成功的处理器就可以开始执行tasklet_obj对象上的延迟函数，执行完毕该tasklet_obj对象将从它所在的处理器tasklet_vec链表中消失，除非再次提交。所以一个成功执行的tasklet_obj对象的状态变化是：\nTASKLET_STATE_SCHED(被成功提交)-->TASKLET_STATE_RUN | TASKLET_STATE_SCHED(被提交并且即将被调度运行)-->TASKLET_STATE_RUN(正在被调度执行中)。\n \n而一个不成功的tasklet要么在tasklet_schedule处就被泯灭掉，此时它根本不会出现在任何一个处理器的tasklet_vec链表中，要么是在同一个tasklet对象正在其他处理器上被执行时被成功提交，但是它目前暂时无法被执行，会被放到它所属的处理器tasklet_vec链表的尾部等待下一次被调度运行。\n\n1.\t同一个tasklet在添加之后，在执行之前不能重新添加\n2.\t同一个tasklet在执行的时候，可以重新添加(同一个CPU或者不同的CPU)，但不可能并行执行\n\n## 参考\nhttp://blog.chinaunix.net/uid-23769728-id-3195496.html\n\n","source":"_posts/Tasklet.md","raw":"---\ntitle: Tasklet\n---\n\n## Tasklet执行方式\n大概有一些同学对tasklet的串行化还有点困惑，其实在单处理器上最好理解，所以本帖主要讨论多处理器上tasklet如何实现串行化：同一个tasklet对象同一时刻只能在一个处理器上运行。\n\n在驱动程序中，tasklet是作为一种softirq形式出现的，所以对tasklet对象的提交一般发生在中断处理例程ISR中。一般一个tasklet用来对同一种中断类型进行后续的处理，所以完全不必要通过动态生成tasklet对象的方式在每次中断到来时重新生成一个tasklet对象来做后半段的处理。事实上Linux内核源码中，几乎所有的tasklet对象都是针对同一类型的中断只产生一个。如果有同学发现有例外的情况，请告诉我，将非常感谢。\n\n假设某个中断发生，由CPU0来处理，在它的ISR中会调用tasklet_schedule来提交一个tasklet对象，假设为tasklet_obj，那么tasklet_schedule首先会为该tasklet对象tasklet_obj.state打上一个标志：TASKLET_STATE_SCHED，表明该tasklet对象被提交但还没有被运行，前述的打标志的操作是个原子，代码里是test_and_set_bit，这意味着如果同时有处理器CPU0和CPU1都来提交该tasklet_obj，那么只有一个会被成功提交，不过不用担心一个tasklet对象没被提交成功的话会有啥副作用，因为在softirq的处理阶段，一个tasklet对象上的处理函数可以一并处理掉外设若干次同一中断要做的事，最典型的，比如网卡连续接收到两个数据包，产生两个中断到两个不同处理器上，因为只有一个tasklet对象被提交，当该对象上的延迟函数被执行时，它会将两个数据包都读到系统内存中。\n \nTASKLET_STATE_SCHED标志是确保tasklet串行化的第一道防线，但是如果该tasklet_obj对象已经被调度到处理器CPU0上运行了，那么TASKLET_STATE_SCHED标志会被清除，这意味着当一个tasklet_obj对象正在一个处理器上运行时，同一个tasklet_obj对象完全可以被提交到另一个处理器，比如CPU1上。那么这种情况下如何确保tasklet串行化呢，答案是tasklet_obj.state上为SMP系统增加的另一个标志位TASKLET_STATE_RUN，当一个tasklet_obj对象被某一处理器开始调度运行时，tasklet_action，也就是对应的softirq处理例程会通过tasklet_trylock来将该tasklet_obj对象的state成员打上标志TASKLET_STATE_RUN，这个操作同样是原子的，因此只会有一个处理器成功完成测试及打标志的动作，没成功的那个处理器上的tasklet_action会把当前的tasklet_obj重新加入到其所管理的tasklet_vec链表的尾部(因为一个相同的tasklet_obj对象已经在运行了，所以再期望其一并完成当前tasklet_obj所表示的任务变得不再可靠，这不同于刚提交时的情形，所以内核对此的策略是，把当前希望运行但是发现已经有同一个tasklet_obj对象的延迟函数正在被执行时，将当前对象加入到处理器tasklet_vec的链表尾部)。那先前成功的处理器就可以开始执行tasklet_obj对象上的延迟函数，执行完毕该tasklet_obj对象将从它所在的处理器tasklet_vec链表中消失，除非再次提交。所以一个成功执行的tasklet_obj对象的状态变化是：\nTASKLET_STATE_SCHED(被成功提交)-->TASKLET_STATE_RUN | TASKLET_STATE_SCHED(被提交并且即将被调度运行)-->TASKLET_STATE_RUN(正在被调度执行中)。\n \n而一个不成功的tasklet要么在tasklet_schedule处就被泯灭掉，此时它根本不会出现在任何一个处理器的tasklet_vec链表中，要么是在同一个tasklet对象正在其他处理器上被执行时被成功提交，但是它目前暂时无法被执行，会被放到它所属的处理器tasklet_vec链表的尾部等待下一次被调度运行。\n\n1.\t同一个tasklet在添加之后，在执行之前不能重新添加\n2.\t同一个tasklet在执行的时候，可以重新添加(同一个CPU或者不同的CPU)，但不可能并行执行\n\n## 参考\nhttp://blog.chinaunix.net/uid-23769728-id-3195496.html\n\n","slug":"Tasklet","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vx000bcbq28xcmh5zo","content":"<h2 id=\"Tasklet执行方式\"><a href=\"#Tasklet执行方式\" class=\"headerlink\" title=\"Tasklet执行方式\"></a>Tasklet执行方式</h2><p>大概有一些同学对tasklet的串行化还有点困惑，其实在单处理器上最好理解，所以本帖主要讨论多处理器上tasklet如何实现串行化：同一个tasklet对象同一时刻只能在一个处理器上运行。</p>\n<p>在驱动程序中，tasklet是作为一种softirq形式出现的，所以对tasklet对象的提交一般发生在中断处理例程ISR中。一般一个tasklet用来对同一种中断类型进行后续的处理，所以完全不必要通过动态生成tasklet对象的方式在每次中断到来时重新生成一个tasklet对象来做后半段的处理。事实上Linux内核源码中，几乎所有的tasklet对象都是针对同一类型的中断只产生一个。如果有同学发现有例外的情况，请告诉我，将非常感谢。</p>\n<p>假设某个中断发生，由CPU0来处理，在它的ISR中会调用tasklet_schedule来提交一个tasklet对象，假设为tasklet_obj，那么tasklet_schedule首先会为该tasklet对象tasklet_obj.state打上一个标志：TASKLET_STATE_SCHED，表明该tasklet对象被提交但还没有被运行，前述的打标志的操作是个原子，代码里是test_and_set_bit，这意味着如果同时有处理器CPU0和CPU1都来提交该tasklet_obj，那么只有一个会被成功提交，不过不用担心一个tasklet对象没被提交成功的话会有啥副作用，因为在softirq的处理阶段，一个tasklet对象上的处理函数可以一并处理掉外设若干次同一中断要做的事，最典型的，比如网卡连续接收到两个数据包，产生两个中断到两个不同处理器上，因为只有一个tasklet对象被提交，当该对象上的延迟函数被执行时，它会将两个数据包都读到系统内存中。</p>\n<p>TASKLET_STATE_SCHED标志是确保tasklet串行化的第一道防线，但是如果该tasklet_obj对象已经被调度到处理器CPU0上运行了，那么TASKLET_STATE_SCHED标志会被清除，这意味着当一个tasklet_obj对象正在一个处理器上运行时，同一个tasklet_obj对象完全可以被提交到另一个处理器，比如CPU1上。那么这种情况下如何确保tasklet串行化呢，答案是tasklet_obj.state上为SMP系统增加的另一个标志位TASKLET_STATE_RUN，当一个tasklet_obj对象被某一处理器开始调度运行时，tasklet_action，也就是对应的softirq处理例程会通过tasklet_trylock来将该tasklet_obj对象的state成员打上标志TASKLET_STATE_RUN，这个操作同样是原子的，因此只会有一个处理器成功完成测试及打标志的动作，没成功的那个处理器上的tasklet_action会把当前的tasklet_obj重新加入到其所管理的tasklet_vec链表的尾部(因为一个相同的tasklet_obj对象已经在运行了，所以再期望其一并完成当前tasklet_obj所表示的任务变得不再可靠，这不同于刚提交时的情形，所以内核对此的策略是，把当前希望运行但是发现已经有同一个tasklet_obj对象的延迟函数正在被执行时，将当前对象加入到处理器tasklet_vec的链表尾部)。那先前成功的处理器就可以开始执行tasklet_obj对象上的延迟函数，执行完毕该tasklet_obj对象将从它所在的处理器tasklet_vec链表中消失，除非再次提交。所以一个成功执行的tasklet_obj对象的状态变化是：<br>TASKLET_STATE_SCHED(被成功提交)–&gt;TASKLET_STATE_RUN | TASKLET_STATE_SCHED(被提交并且即将被调度运行)–&gt;TASKLET_STATE_RUN(正在被调度执行中)。</p>\n<p>而一个不成功的tasklet要么在tasklet_schedule处就被泯灭掉，此时它根本不会出现在任何一个处理器的tasklet_vec链表中，要么是在同一个tasklet对象正在其他处理器上被执行时被成功提交，但是它目前暂时无法被执行，会被放到它所属的处理器tasklet_vec链表的尾部等待下一次被调度运行。</p>\n<ol>\n<li>   同一个tasklet在添加之后，在执行之前不能重新添加</li>\n<li>   同一个tasklet在执行的时候，可以重新添加(同一个CPU或者不同的CPU)，但不可能并行执行</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.chinaunix.net/uid-23769728-id-3195496.html\">http://blog.chinaunix.net/uid-23769728-id-3195496.html</a></p>\n","cover":false,"excerpt":"","more":"<h2 id=\"Tasklet执行方式\"><a href=\"#Tasklet执行方式\" class=\"headerlink\" title=\"Tasklet执行方式\"></a>Tasklet执行方式</h2><p>大概有一些同学对tasklet的串行化还有点困惑，其实在单处理器上最好理解，所以本帖主要讨论多处理器上tasklet如何实现串行化：同一个tasklet对象同一时刻只能在一个处理器上运行。</p>\n<p>在驱动程序中，tasklet是作为一种softirq形式出现的，所以对tasklet对象的提交一般发生在中断处理例程ISR中。一般一个tasklet用来对同一种中断类型进行后续的处理，所以完全不必要通过动态生成tasklet对象的方式在每次中断到来时重新生成一个tasklet对象来做后半段的处理。事实上Linux内核源码中，几乎所有的tasklet对象都是针对同一类型的中断只产生一个。如果有同学发现有例外的情况，请告诉我，将非常感谢。</p>\n<p>假设某个中断发生，由CPU0来处理，在它的ISR中会调用tasklet_schedule来提交一个tasklet对象，假设为tasklet_obj，那么tasklet_schedule首先会为该tasklet对象tasklet_obj.state打上一个标志：TASKLET_STATE_SCHED，表明该tasklet对象被提交但还没有被运行，前述的打标志的操作是个原子，代码里是test_and_set_bit，这意味着如果同时有处理器CPU0和CPU1都来提交该tasklet_obj，那么只有一个会被成功提交，不过不用担心一个tasklet对象没被提交成功的话会有啥副作用，因为在softirq的处理阶段，一个tasklet对象上的处理函数可以一并处理掉外设若干次同一中断要做的事，最典型的，比如网卡连续接收到两个数据包，产生两个中断到两个不同处理器上，因为只有一个tasklet对象被提交，当该对象上的延迟函数被执行时，它会将两个数据包都读到系统内存中。</p>\n<p>TASKLET_STATE_SCHED标志是确保tasklet串行化的第一道防线，但是如果该tasklet_obj对象已经被调度到处理器CPU0上运行了，那么TASKLET_STATE_SCHED标志会被清除，这意味着当一个tasklet_obj对象正在一个处理器上运行时，同一个tasklet_obj对象完全可以被提交到另一个处理器，比如CPU1上。那么这种情况下如何确保tasklet串行化呢，答案是tasklet_obj.state上为SMP系统增加的另一个标志位TASKLET_STATE_RUN，当一个tasklet_obj对象被某一处理器开始调度运行时，tasklet_action，也就是对应的softirq处理例程会通过tasklet_trylock来将该tasklet_obj对象的state成员打上标志TASKLET_STATE_RUN，这个操作同样是原子的，因此只会有一个处理器成功完成测试及打标志的动作，没成功的那个处理器上的tasklet_action会把当前的tasklet_obj重新加入到其所管理的tasklet_vec链表的尾部(因为一个相同的tasklet_obj对象已经在运行了，所以再期望其一并完成当前tasklet_obj所表示的任务变得不再可靠，这不同于刚提交时的情形，所以内核对此的策略是，把当前希望运行但是发现已经有同一个tasklet_obj对象的延迟函数正在被执行时，将当前对象加入到处理器tasklet_vec的链表尾部)。那先前成功的处理器就可以开始执行tasklet_obj对象上的延迟函数，执行完毕该tasklet_obj对象将从它所在的处理器tasklet_vec链表中消失，除非再次提交。所以一个成功执行的tasklet_obj对象的状态变化是：<br>TASKLET_STATE_SCHED(被成功提交)–&gt;TASKLET_STATE_RUN | TASKLET_STATE_SCHED(被提交并且即将被调度运行)–&gt;TASKLET_STATE_RUN(正在被调度执行中)。</p>\n<p>而一个不成功的tasklet要么在tasklet_schedule处就被泯灭掉，此时它根本不会出现在任何一个处理器的tasklet_vec链表中，要么是在同一个tasklet对象正在其他处理器上被执行时被成功提交，但是它目前暂时无法被执行，会被放到它所属的处理器tasklet_vec链表的尾部等待下一次被调度运行。</p>\n<ol>\n<li>   同一个tasklet在添加之后，在执行之前不能重新添加</li>\n<li>   同一个tasklet在执行的时候，可以重新添加(同一个CPU或者不同的CPU)，但不可能并行执行</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.chinaunix.net/uid-23769728-id-3195496.html\">http://blog.chinaunix.net/uid-23769728-id-3195496.html</a></p>\n"},{"_content":"\n","source":"_posts/TraceEvent.md","raw":"\n","slug":"TraceEvent","published":1,"date":"2024-08-09T11:31:52.418Z","updated":"2024-08-09T11:31:52.419Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vx000ccbq2gpeob5t7","content":"","cover":false,"excerpt":"","more":""},{"title":"Workqueue","_content":"\n## 查看workqueue在干什么\n1) 通过cat查看workqueue的调用栈\n  cat /proc/<kworker_pid>/stack\n2) trace-cmd方式查看\n  trace-cmd record -e workqueue:workqueue_queue_work\n  trace-cmd report > trace.log\n  You can get list of the most frequently queued to least frequently queued workqueue functions with the following:\n    grep -o -e \"function=[_a-zA-Z_][_a-zA-Z0-9]*\" trace.log|sort|uniq -c |sort -rn\n\n## 接口使用注意\n#### cancle_work_sync\n如果work的回调函数中有等待信号量等操作的时候，直接调用destroy_workqueue是会有报错的。\n正确的做法是\n1) 唤醒work回调函数的信号量等待\n2) 调用cancel_work_sync等待work结束\n3) 调用destroy_workqueue销毁workqueue\n","source":"_posts/Workqueue.md","raw":"---\ntitle: Workqueue\n---\n\n## 查看workqueue在干什么\n1) 通过cat查看workqueue的调用栈\n  cat /proc/<kworker_pid>/stack\n2) trace-cmd方式查看\n  trace-cmd record -e workqueue:workqueue_queue_work\n  trace-cmd report > trace.log\n  You can get list of the most frequently queued to least frequently queued workqueue functions with the following:\n    grep -o -e \"function=[_a-zA-Z_][_a-zA-Z0-9]*\" trace.log|sort|uniq -c |sort -rn\n\n## 接口使用注意\n#### cancle_work_sync\n如果work的回调函数中有等待信号量等操作的时候，直接调用destroy_workqueue是会有报错的。\n正确的做法是\n1) 唤醒work回调函数的信号量等待\n2) 调用cancel_work_sync等待work结束\n3) 调用destroy_workqueue销毁workqueue\n","slug":"Workqueue","published":1,"date":"2024-08-09T10:53:15.490Z","updated":"2024-08-09T10:53:15.490Z","comments":1,"layout":"post","photos":[],"_id":"clzmmn5vx000dcbq2foa710nb","content":"<h2 id=\"查看workqueue在干什么\"><a href=\"#查看workqueue在干什么\" class=\"headerlink\" title=\"查看workqueue在干什么\"></a>查看workqueue在干什么</h2><ol>\n<li>通过cat查看workqueue的调用栈<br>  cat &#x2F;proc&#x2F;<kworker_pid>&#x2F;stack</li>\n<li>trace-cmd方式查看<br>  trace-cmd record -e workqueue:workqueue_queue_work<br>  trace-cmd report &gt; trace.log<br>  You can get list of the most frequently queued to least frequently queued workqueue functions with the following:<br> grep -o -e “function&#x3D;[<em>a-zA-Z</em>][_a-zA-Z0-9]*” trace.log|sort|uniq -c |sort -rn</li>\n</ol>\n<h2 id=\"接口使用注意\"><a href=\"#接口使用注意\" class=\"headerlink\" title=\"接口使用注意\"></a>接口使用注意</h2><h4 id=\"cancle-work-sync\"><a href=\"#cancle-work-sync\" class=\"headerlink\" title=\"cancle_work_sync\"></a>cancle_work_sync</h4><p>如果work的回调函数中有等待信号量等操作的时候，直接调用destroy_workqueue是会有报错的。<br>正确的做法是</p>\n<ol>\n<li>唤醒work回调函数的信号量等待</li>\n<li>调用cancel_work_sync等待work结束</li>\n<li>调用destroy_workqueue销毁workqueue</li>\n</ol>\n","cover":false,"excerpt":"","more":"<h2 id=\"查看workqueue在干什么\"><a href=\"#查看workqueue在干什么\" class=\"headerlink\" title=\"查看workqueue在干什么\"></a>查看workqueue在干什么</h2><ol>\n<li>通过cat查看workqueue的调用栈<br>  cat &#x2F;proc&#x2F;<kworker_pid>&#x2F;stack</li>\n<li>trace-cmd方式查看<br>  trace-cmd record -e workqueue:workqueue_queue_work<br>  trace-cmd report &gt; trace.log<br>  You can get list of the most frequently queued to least frequently queued workqueue functions with the following:<br> grep -o -e “function&#x3D;[<em>a-zA-Z</em>][_a-zA-Z0-9]*” trace.log|sort|uniq -c |sort -rn</li>\n</ol>\n<h2 id=\"接口使用注意\"><a href=\"#接口使用注意\" class=\"headerlink\" title=\"接口使用注意\"></a>接口使用注意</h2><h4 id=\"cancle-work-sync\"><a href=\"#cancle-work-sync\" class=\"headerlink\" title=\"cancle_work_sync\"></a>cancle_work_sync</h4><p>如果work的回调函数中有等待信号量等操作的时候，直接调用destroy_workqueue是会有报错的。<br>正确的做法是</p>\n<ol>\n<li>唤醒work回调函数的信号量等待</li>\n<li>调用cancel_work_sync等待work结束</li>\n<li>调用destroy_workqueue销毁workqueue</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}