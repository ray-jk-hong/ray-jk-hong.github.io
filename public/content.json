{"meta":{"title":"Ray","subtitle":"","description":"","author":"Ray","url":"https://ray-jk-hong.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-08-10T10:49:49.000Z","updated":"2024-08-10T10:50:51.038Z","comments":true,"path":"categories/index.html","permalink":"https://ray-jk-hong.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-08-10T10:56:20.000Z","updated":"2024-08-10T10:57:11.739Z","comments":true,"path":"tags/index.html","permalink":"https://ray-jk-hong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TraceEvent","slug":"TraceEvent","date":"2024-08-10T10:31:17.359Z","updated":"2024-08-10T16:14:25.065Z","comments":true,"path":"2024/08/10/TraceEvent/","permalink":"https://ray-jk-hong.github.io/2024/08/10/TraceEvent/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"}]},{"title":"MMU","slug":"MMU","date":"2024-08-10T10:31:17.358Z","updated":"2024-08-11T09:54:32.248Z","comments":true,"path":"2024/08/10/MMU/","permalink":"https://ray-jk-hong.github.io/2024/08/10/MMU/","excerpt":"","text":"TLBTLB介绍TLB是一个cache、是保存MMU最近转换过的内容(TLB hit)。在每次MMU地址转换的时候、都会先查看TLB中是否存在、如果有的话就可以直接访问。如果TLB中没有(TLB miss)、就会通过MMU做转换并保存在TLB中。TLB中不仅保存虚拟地址和对应的物理地址、也保存1) attributes such as memory type (见memory ordering)2) cache policies3) access permissions4) the Address Space ID (ASID), and the Virtual Machine ID (VMID)。 如果MMU页表在建立之后、中途需要调整变化、在修改完MMU对应的页表之后、就要刷新(invalidate)TLB。 TLB刷新TLBI命令就是负责刷新TLB。 TLBI {IS} {, } type字段：ALL：刷新所有TLB entryVMALL: 刷新所有stage 1TLB entry MMUMMU寄存器TCR(Translation Control Register)寄存器（包含TCR_EL1&#x2F;TCR_EL2&#x2F;TCR_EL3这几种）(D8-2038)TCR寄存器位分配T1SZ&#x2F;T0SZ表示TTBR0_ELx能表示的地址范围，地址范围的计算公式就是2^(64-T1SZ) Bytest:例如：如果用户态地址范围是48位虚拟地址，那这里应该配置T0SZ&#x3D;64-48&#x3D;16, 虚拟地址的范围是 2^(64-16) &#x3D; 0 ~ 0x0000_FFFF_FFFF_FFFF TTBR(Translation Table Base Register)寄存器TTBR0_EL1, TTBR1_EL1寄存器TTBR寄存器介绍Stage1的页表翻译时，MMU页表的基地址由TTBR0_EL1, TTBR1_EL1指定。TTBR0_EL1指定用户态页表基地址，TTBR1_EL1指定内核态的页表基地址。EL2和EL3有TTBR0但没有TTBR1(就是说EL2有TTBR0_EL2, EL3有TTBR_EL3，但没有TTBR1_EL2和TTRB1_EL3)。 EL2&#x2F;EL3如果是aarch64, 也只能使用0x0-0x0000FFFF_FFFFFFFF范围的地址（对地址范围有疑问看下一节TTBR地址范围确定一节）。用户态不能直接访问MMU，当然也没有所谓的TTBR0_EL0，TTBR1_EL0之类的寄存器了。 TTBR地址范围确定 如何选择（D5-1736）TTBR位分配 ASID是做什么？ VTTBR_EL2页表设置保存stage2的页表基地址 PTE_SHARED pgprot_val（PAGE_KERNEL） pteval_t 这些都有什么不同 页表walkhttps://github.com/rcore-os/rCore/blob/master/docs/2_OSLab/g2/memory.md https://blog.csdn.net/2301_79143213/article/details/137247214?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-137247214-blog-109057232.235^v43^pc_blog_bottom_relevance_base1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3 https://blog.csdn.net/weixin_42135087/article/details/109057232","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"MMU","slug":"MMU","permalink":"https://ray-jk-hong.github.io/tags/MMU/"}]},{"title":"Kvm","slug":"Kvm","date":"2024-08-10T10:31:17.358Z","updated":"2024-08-10T16:14:38.666Z","comments":true,"path":"2024/08/10/Kvm/","permalink":"https://ray-jk-hong.github.io/2024/08/10/Kvm/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Virt","slug":"Linux-Virt","permalink":"https://ray-jk-hong.github.io/tags/Linux-Virt/"}]},{"title":"HugeTLB","slug":"HugeTLB","date":"2024-08-10T10:31:17.357Z","updated":"2024-08-10T16:13:37.995Z","comments":true,"path":"2024/08/10/HugeTLB/","permalink":"https://ray-jk-hong.github.io/2024/08/10/HugeTLB/","excerpt":"","text":"参考https://blog.csdn.net/wangquan1992/article/details/103963108https://blog.csdn.net/hbuxiaofei/article/details/128402495https://blog.csdn.net/tony_vip/article/details/113791585 https://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf 为什么使用大页大页提高性能大页能提高性能的原理：MMU翻译页表，按照2MB翻译，到PMD这层就可以了，不用翻译到PTE阶段。 大页类型HugeTLB机制： hstate管理大页，从伙伴系统申请，由order值决定大小。小于order的由伙伴系统申请，大于order的由memblock预留内存中申请或者调用alloc_cont_range申请。 HugeTLB机制：hugetlbfs文件系统 (1) HugeTLB就是透过hugetlbfs方式向文件系统提供使用HugeTLB大页机制 (2) hugetlbfs创建的文件可以被读系统调用操作，但不允许写系统调用操作，可以mmap映射 复合大页（Compound pages）：多个page组合起来管理连续内存空间透明大页（Transparent Huge Pages）：伙伴系统直接动态分配 透明大页机制介绍：khugepaged线程 Hash表是为了便于通过mm_struct指针地址，来找到对应的mm_slot结构 Khugepaged_scan管理的链表是透明大页遍历扫描的链表，透明大页遍历每个mm_slot 的mm_struct 通过mm_struct，遍历每个vma数据结构，扫描vma的地址空间，每次按2M大小扫描对应的pte内容 透明大页由于性能抖动以及挂死等问题，被禁用：https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/ 如何使用大页用户态使用大页 用户态使用大页有以下几种方法： mount一个特殊的hugetlbfs文件系统，在上面创建文件，然后用mmap()进行访问, 但文件是只读的。也可以使用libhugetlbfs。 shmget&#x2F;shmat，调用shmget申请共享内存加上SHM_HUGETLB标志。 mmap()时指定MAAP_HUGETLB标志。 memfd的memfd_create传MFD_HUGETLB标记 mmap方式使用示例 cat &#x2F;proc&#x2F;meminfo | grep -i huge查看大页预留情况AnonHugePages: 2048 kBHugePages_Total: 200HugePages_Free: 200HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kB 预留大页（200个大页）echo 200 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;nr_huagepages或者sysctl vm.nr_hugepages&#x3D;200 mmap + memset的时候，在mmap参数中添加MAP_HUGETLB申请使用大页例如：(1) 申请使用大页 size &#x3D; 2 * 1024 * 1024; addr &#x3D; mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | 0x40000 &#x2F;MAP_HUGETLB&#x2F;, -1, 0); memset(addr, 0, size);(2) 重新查看大页使用情况 AnonHugePages: 2048 kB HugePages_Total: 200 HugePages_Free: 199 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB mount hugetlbfs方式示例 libhugetlbfs：使用大页，将用户态程序的text&#x2F;data&#x2F;BSS保存到大页功能，提高性能 shmemget方式示例 shmem大页：https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux 内核态申请大页","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux MM","slug":"Linux-MM","permalink":"https://ray-jk-hong.github.io/tags/Linux-MM/"}]},{"title":"Ftrace","slug":"Ftrace","date":"2024-08-09T11:31:52.418Z","updated":"2024-08-10T16:13:33.174Z","comments":true,"path":"2024/08/09/Ftrace/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Ftrace/","excerpt":"","text":"Ftrace原理gcc编译时添加-pg编译选项。这个编译选项在函数开始处添加-bl指令 Ftrace跟踪函数cd &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;echo 0 &gt; tracing_onecho 5 &gt; max_graph_depthecho function_graph &gt; current_tracerecho 1 &gt; options&#x2F;func_stack_traceecho xxx &gt; set_graph_function ## set_ftrace_filter这个只能打印本函数没法打印子函数等，而set_graph_function是可以打印子函数，而且可以看到函数是不是在执行过程中被中断切出去了echo 0 &gt; traceecho 1 &gt; tracing_on .&#x2F;a.out 执行完程序echo 0 &gt; tracing_oncat trace https://www.cnblogs.com/arnoldlu/p/7211249.html set_graph_functionIf you want to trace only one function and all of its children,you just have to echo its name into set_graph_function: Trace-cmdhttps://man7.org/linux/man-pages/man1/trace-cmd-record.1.html使用trace-cmd record -e workqueue:workqueue_queue_work查看workqueue在执行时cpu 100%的问题https://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2 Trace EventTrace Event添加应用参考https://docs.kernel.org/trace/tracepoints.htmlhttps://www.kernel.org/doc/Documentation/trace/ftrace.txt","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"}]},{"title":"Process Schedule","slug":"ProcessSchedule","date":"2024-08-09T11:31:52.418Z","updated":"2024-08-10T16:13:19.655Z","comments":true,"path":"2024/08/09/ProcessSchedule/","permalink":"https://ray-jk-hong.github.io/2024/08/09/ProcessSchedule/","excerpt":"","text":"进程sched事件追踪[sched事件追踪]123456789cd /sys/kernel/debug/tracing/events/schedecho 1 &gt; sched_switch/enableecho 1 &gt; sched_wakeup/enableecho 1 &gt; sched_wakeup_new/enableecho 1 &gt; sched_waking/enableecho 1 &gt; sched_process_fork/enableecho 1 &gt; sched_stat_runtime/enableecho 1 &gt; /sys/kernel/debug/tracing/events/irq/enableecho 1 &gt; /sys/kernel/debug/tracing/tracing_on","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Process","slug":"Linux-Process","permalink":"https://ray-jk-hong.github.io/tags/Linux-Process/"}]},{"title":"Kprobe","slug":"Kprobe","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-10T16:21:43.292Z","comments":true,"path":"2024/08/09/Kprobe/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Kprobe/","excerpt":"","text":"内核态注册https://docs.kernel.org/trace/kprobes.html 用户态使用Kprobe探测内核函数开启关闭Kprobe 开启：echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable 关闭：echo 0 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable 设置Kprobe探测点 返回值打印：1echo &#x27;r 函数名 ret=$retval&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events 入参打印: x86平台使用%ax, %bx, %cx, %dx表示第0-3个参数。arm平台使用x0, x1, x2, x3来表示第0-3个参数。Linux4.x版本之后，应该都可以使用arg0, arg1等方式表示。 2.1 函数的参数直接打印值： X86打印第一个第二个参数: 1echo &#x27;p function_name a=%ax:s32 b=%bx:u64&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events ARM打印第一个和第二个参数: 1echo &#x27;p function_name a=%x0:x64 b=%x1&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events 这里参数:后面s32, u64, x64等都表示的是需要打印的类型。x64表示按照16禁止打印，数据位宽就是64bit（8字节） 2.2 函数参数是指针，打印指针里边的内容： 1echo &#x27;p function_name +0(%x1):x64 +8(%x1):x64 +16(%x1):x64&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events +0(指针)表示解引用指针。按照上面的打印，第二个参数就是指针，+0(%x1):x64就是表示第二个参数指针偏移0并按照x64方式打印。 查看结果1cat /sys/kernel/debug/tracing/trace 清空结果1echo &gt; /sys/kernel/debug/tracing/trace 查看调用栈1echo 1 &gt; /sys/kernel/debug/tracing/options/stacktrace 过滤入参1echo &#x27;arg2==期望的值&#x27; &gt; /sys/kernel/debug/tracing/events/kprobes/p_函数名_0/filter 挂死打印当内核panic的时候ftrace_dump函数会将trace缓冲区里边的内容打印到内核日志中。 1echo 1 &gt; /proc/sys/kernel/ftrace_dump_on_oops 例如：调用栈显示某个函数有挂死现象，则可以按照上述方式打开并跟踪参数情况，可以追踪哪些参数传到函数中导致的异常","categories":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/categories/Linux-Trace/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"}]},{"title":"Rcu (Read Copy Update)","slug":"Rcu","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-10T16:13:48.756Z","comments":true,"path":"2024/08/09/Rcu/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Rcu/","excerpt":"","text":"参考https://zhuanlan.zhihu.com/p/30583695http://www.wowotech.net/kernel_synchronization/rcu_fundamentals.htmlhttp://3ms.huawei.com/km/blogs/details/12175655 http://3ms.huawei.com/km/blogs/details/5886747https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit http://3ms.huawei.com/km/blogs/details/125081 例子：https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux RCU","slug":"Linux-RCU","permalink":"https://ray-jk-hong.github.io/tags/Linux-RCU/"}]},{"title":"Spinlock","slug":"Spinlock","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-10T16:14:09.159Z","comments":true,"path":"2024/08/09/Spinlock/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Spinlock/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Spinlock","slug":"Linux-Spinlock","permalink":"https://ray-jk-hong.github.io/tags/Linux-Spinlock/"}]},{"title":"Tasklet","slug":"Tasklet","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-10T16:14:16.933Z","comments":true,"path":"2024/08/09/Tasklet/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Tasklet/","excerpt":"","text":"Tasklet执行方式大概有一些同学对tasklet的串行化还有点困惑，其实在单处理器上最好理解，所以本帖主要讨论多处理器上tasklet如何实现串行化：同一个tasklet对象同一时刻只能在一个处理器上运行。 在驱动程序中，tasklet是作为一种softirq形式出现的，所以对tasklet对象的提交一般发生在中断处理例程ISR中。一般一个tasklet用来对同一种中断类型进行后续的处理，所以完全不必要通过动态生成tasklet对象的方式在每次中断到来时重新生成一个tasklet对象来做后半段的处理。事实上Linux内核源码中，几乎所有的tasklet对象都是针对同一类型的中断只产生一个。如果有同学发现有例外的情况，请告诉我，将非常感谢。 假设某个中断发生，由CPU0来处理，在它的ISR中会调用tasklet_schedule来提交一个tasklet对象，假设为tasklet_obj，那么tasklet_schedule首先会为该tasklet对象tasklet_obj.state打上一个标志：TASKLET_STATE_SCHED，表明该tasklet对象被提交但还没有被运行，前述的打标志的操作是个原子，代码里是test_and_set_bit，这意味着如果同时有处理器CPU0和CPU1都来提交该tasklet_obj，那么只有一个会被成功提交，不过不用担心一个tasklet对象没被提交成功的话会有啥副作用，因为在softirq的处理阶段，一个tasklet对象上的处理函数可以一并处理掉外设若干次同一中断要做的事，最典型的，比如网卡连续接收到两个数据包，产生两个中断到两个不同处理器上，因为只有一个tasklet对象被提交，当该对象上的延迟函数被执行时，它会将两个数据包都读到系统内存中。 TASKLET_STATE_SCHED标志是确保tasklet串行化的第一道防线，但是如果该tasklet_obj对象已经被调度到处理器CPU0上运行了，那么TASKLET_STATE_SCHED标志会被清除，这意味着当一个tasklet_obj对象正在一个处理器上运行时，同一个tasklet_obj对象完全可以被提交到另一个处理器，比如CPU1上。那么这种情况下如何确保tasklet串行化呢，答案是tasklet_obj.state上为SMP系统增加的另一个标志位TASKLET_STATE_RUN，当一个tasklet_obj对象被某一处理器开始调度运行时，tasklet_action，也就是对应的softirq处理例程会通过tasklet_trylock来将该tasklet_obj对象的state成员打上标志TASKLET_STATE_RUN，这个操作同样是原子的，因此只会有一个处理器成功完成测试及打标志的动作，没成功的那个处理器上的tasklet_action会把当前的tasklet_obj重新加入到其所管理的tasklet_vec链表的尾部(因为一个相同的tasklet_obj对象已经在运行了，所以再期望其一并完成当前tasklet_obj所表示的任务变得不再可靠，这不同于刚提交时的情形，所以内核对此的策略是，把当前希望运行但是发现已经有同一个tasklet_obj对象的延迟函数正在被执行时，将当前对象加入到处理器tasklet_vec的链表尾部)。那先前成功的处理器就可以开始执行tasklet_obj对象上的延迟函数，执行完毕该tasklet_obj对象将从它所在的处理器tasklet_vec链表中消失，除非再次提交。所以一个成功执行的tasklet_obj对象的状态变化是：TASKLET_STATE_SCHED(被成功提交)–&gt;TASKLET_STATE_RUN | TASKLET_STATE_SCHED(被提交并且即将被调度运行)–&gt;TASKLET_STATE_RUN(正在被调度执行中)。 而一个不成功的tasklet要么在tasklet_schedule处就被泯灭掉，此时它根本不会出现在任何一个处理器的tasklet_vec链表中，要么是在同一个tasklet对象正在其他处理器上被执行时被成功提交，但是它目前暂时无法被执行，会被放到它所属的处理器tasklet_vec链表的尾部等待下一次被调度运行。 同一个tasklet在添加之后，在执行之前不能重新添加 同一个tasklet在执行的时候，可以重新添加(同一个CPU或者不同的CPU)，但不可能并行执行 参考http://blog.chinaunix.net/uid-23769728-id-3195496.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Tasklet","slug":"Linux-Tasklet","permalink":"https://ray-jk-hong.github.io/tags/Linux-Tasklet/"}]},{"title":"Workqueue","slug":"Workqueue","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-10T16:16:58.703Z","comments":true,"path":"2024/08/09/Workqueue/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Workqueue/","excerpt":"","text":"Workqueue问题定位Work消耗太多CPU Cycles(Top命令能看到)Worker线程通过ps命令打印如下：‘’‘root 5671 0.0 0.0 0 0 ? S 12:07 0:00 [kworker&#x2F;0:1]root 5672 0.0 0.0 0 0 ? S 12:07 0:00 [kworker&#x2F;1:2]root 5673 0.0 0.0 0 0 ? S 12:12 0:00 [kworker&#x2F;0:0]root 5674 0.0 0.0 0 0 ? S 12:13 0:00 [kworker&#x2F;1:0]’‘’ 以下几种可能1.Work切换频繁 1234$echo workqueue:workqueue_queue_work &gt; /sys/kernel/tracing/set_event$cat /sys/kernel/tracing/trace_pipe &gt; out.txt (wait a few secs) ^C 这样可以看到所有的Work执行的情况。 1&lt;idle&gt;-0 [005] dNs.. 25598.686997: workqueue_queue_work: work struct=00000000b8691ef7 function=nf_flow_offload_work_gc workqueue=events_power_efficient req_cpu=24 cpu=-1 function&#x3D;‘Work函数名’就是Work的函数。 2.Work一次执行消耗太多使用如下方式查看kwork的调用栈。 1$cat /proc/THE_OFFENDING_KWORKER/stack THE_OFFENDING_KWORKER就是Worker线程的pid。 接口使用注意cancle_work_sync如果work的回调函数中有等待信号量等操作的时候，直接调用destroy_workqueue是会有报错的。正确的做法是: 1.唤醒work回调函数的信号量等待 2.调用cancel_work_sync等待work结束 3.调用destroy_workqueue销毁workqueue","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Workqueue","slug":"Linux-Workqueue","permalink":"https://ray-jk-hong.github.io/tags/Linux-Workqueue/"}]},{"title":"DeviceModel","slug":"DeviceModel","date":"2024-08-09T10:53:15.489Z","updated":"2024-08-10T11:13:02.238Z","comments":true,"path":"2024/08/09/DeviceModel/","permalink":"https://ray-jk-hong.github.io/2024/08/09/DeviceModel/","excerpt":"","text":"","categories":[{"name":"Linux Driver","slug":"Linux-Driver","permalink":"https://ray-jk-hong.github.io/categories/Linux-Driver/"}],"tags":[{"name":"Linux Driver","slug":"Linux-Driver","permalink":"https://ray-jk-hong.github.io/tags/Linux-Driver/"}]},{"title":"GIC","slug":"GIC","date":"2024-08-09T10:53:15.489Z","updated":"2024-08-10T16:12:47.653Z","comments":true,"path":"2024/08/09/GIC/","permalink":"https://ray-jk-hong.github.io/2024/08/09/GIC/","excerpt":"","text":"","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"GIC","slug":"GIC","permalink":"https://ray-jk-hong.github.io/tags/GIC/"}]},{"title":"FileSystem","slug":"FileSystem","date":"2024-08-09T10:53:15.489Z","updated":"2024-08-10T16:13:28.241Z","comments":true,"path":"2024/08/09/FileSystem/","permalink":"https://ray-jk-hong.github.io/2024/08/09/FileSystem/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux File System","slug":"Linux-File-System","permalink":"https://ray-jk-hong.github.io/tags/Linux-File-System/"}]},{"title":"I2C协议","slug":"I2C Protocol","date":"2024-08-09T10:53:15.489Z","updated":"2024-08-10T16:24:43.930Z","comments":true,"path":"2024/08/09/I2C Protocol/","permalink":"https://ray-jk-hong.github.io/2024/08/09/I2C%20Protocol/","excerpt":"","text":"I2C协议综述I2C总线包含两条线，SDA(串行数据线)&#x2F;SDL(串行时钟线). 原理是通过SDA&#x2F;SDL的电平高低的时序控制来进行数据的传递。在空闲状态时，这两个线一般被上面所接的上拉电阻拉高，保持高电平。I2C是半双工通信方式，同一时间只能单向通信。通信速度根据通信模式如下：(1) 标准模式：100Kbit&#x2F;s(2) 快速模式：400Kbit&#x2F;s(3) 高速模式：3.4Mbit&#x2F;s。 I2C主设备&#x2F;从设备I2C的是分主设备与从设备的。 I2C通信时，通信设备之间的地位是平等的，分为主设备和从设备，其中主设备一个、从设备多个。主设备要主导整个通信过程，从设备根据I2C协议被动的响应主设备； 在I2C通信中，没有规定谁做主设备、谁做从设备，是通信双方自己协商的。一个设备在同一时间只能做主设备或者从设备，但是有的设备可以通过软件配置来决定在此次通信时做主设备还是从设备。 I2C总线I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA&#x2F;SDL电平高低，I2C总线状态可以分为如下几种： SDA&#x2F;SDL高电平：空闲 SDA由高变低，SDL高电平：开始信号 SDL由低变高：SDL高电平：结束信号 I2C总线状态转移：在开始条件产生后，总线出于忙状态，总线由数据传输的主从设备独占，其他I2C期间无法访问总线。在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次出于空闲状态。 I2C数据传输：I2C发送完开始信号之后，&#x3D;&#x3D;主设备&#x3D;&#x3D; 在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着&#x3D;&#x3D;从设备&#x3D;&#x3D;将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否定应答位。ACK信号就是从设备在拉低SDA之后，再给一个SDL脉冲？","categories":[{"name":"I2C","slug":"I2C","permalink":"https://ray-jk-hong.github.io/categories/I2C/"}],"tags":[{"name":"I2C Protocol","slug":"I2C-Protocol","permalink":"https://ray-jk-hong.github.io/tags/I2C-Protocol/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"},{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"},{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/categories/Linux-Trace/"},{"name":"Linux Driver","slug":"Linux-Driver","permalink":"https://ray-jk-hong.github.io/categories/Linux-Driver/"},{"name":"I2C","slug":"I2C","permalink":"https://ray-jk-hong.github.io/categories/I2C/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"},{"name":"MMU","slug":"MMU","permalink":"https://ray-jk-hong.github.io/tags/MMU/"},{"name":"Linux Virt","slug":"Linux-Virt","permalink":"https://ray-jk-hong.github.io/tags/Linux-Virt/"},{"name":"Linux MM","slug":"Linux-MM","permalink":"https://ray-jk-hong.github.io/tags/Linux-MM/"},{"name":"Linux Process","slug":"Linux-Process","permalink":"https://ray-jk-hong.github.io/tags/Linux-Process/"},{"name":"Linux RCU","slug":"Linux-RCU","permalink":"https://ray-jk-hong.github.io/tags/Linux-RCU/"},{"name":"Linux Spinlock","slug":"Linux-Spinlock","permalink":"https://ray-jk-hong.github.io/tags/Linux-Spinlock/"},{"name":"Linux Tasklet","slug":"Linux-Tasklet","permalink":"https://ray-jk-hong.github.io/tags/Linux-Tasklet/"},{"name":"Linux Workqueue","slug":"Linux-Workqueue","permalink":"https://ray-jk-hong.github.io/tags/Linux-Workqueue/"},{"name":"Linux Driver","slug":"Linux-Driver","permalink":"https://ray-jk-hong.github.io/tags/Linux-Driver/"},{"name":"GIC","slug":"GIC","permalink":"https://ray-jk-hong.github.io/tags/GIC/"},{"name":"Linux File System","slug":"Linux-File-System","permalink":"https://ray-jk-hong.github.io/tags/Linux-File-System/"},{"name":"I2C Protocol","slug":"I2C-Protocol","permalink":"https://ray-jk-hong.github.io/tags/I2C-Protocol/"}]}