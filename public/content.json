{"meta":{"title":"Ray","subtitle":"","description":"","author":"Ray","url":"https://ray-jk-hong.github.io","root":"/"},"pages":[{"title":"tags","date":"2024-08-10T10:56:20.000Z","updated":"2024-08-10T10:57:11.739Z","comments":true,"path":"tags/index.html","permalink":"https://ray-jk-hong.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-08-10T10:49:49.000Z","updated":"2024-08-10T10:50:51.038Z","comments":true,"path":"categories/index.html","permalink":"https://ray-jk-hong.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Cgroup","slug":"Cgroup","date":"2024-08-17T12:40:18.491Z","updated":"2024-08-17T12:40:18.491Z","comments":true,"path":"2024/08/17/Cgroup/","permalink":"https://ray-jk-hong.github.io/2024/08/17/Cgroup/","excerpt":"","text":"12345678910@startuml class Example &#123; - String name - int number +void getName() +void getNumber() +String toString() &#125;@enduml","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Cgroup","slug":"Linux-Cgroup","permalink":"https://ray-jk-hong.github.io/tags/Linux-Cgroup/"}]},{"title":"Smmu","slug":"Smmu","date":"2024-08-16T12:53:51.257Z","updated":"2024-08-16T12:53:51.257Z","comments":true,"path":"2024/08/16/Smmu/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Smmu/","excerpt":"","text":"VMID&#x2F;ASID&#x2F;PASID概念VMID：每个虚拟机都被赋予一个VMID。VMID用于标识TLB项，区分每个TLB是属于哪个虚拟机。这允许多个不同的虚拟机转换在同一时间内在TLB中存在。 ASID：在多进程的情况下，每次切换进程都需要进行TLB清理。这样会导致切换的效率变低。为了解决问题，TLB 引入了 ASID(Address Space ID) 。ASID 的范围是 0-255。ASID 由操作系统分配，当前进程的ASID值被写在 ASID 寄存器 (使用CP15 c3访问)。TLB 在更新页表项时也会将 ASID 写入 TLB。 PASID(Process Address Space ID) ，地址空间ID，是EP的本地ID，每个function都有一组不同的PASID，不同function间的PASID互不相关。带有PASID的TLP Prefix是一种End-End的TLP前缀，PASID与Requester ID一起共同作为请求TLP地址空间的唯一标识。同一PASID在同一系统中可以重复使用。PASID用来对多个进程进行区分。 PASID获取iommu_sva_bind_deviceiommu_sva_get_pasid获取pasid PASID的意义https://blog.csdn.net/yiyeguzhou100/article/details/128069086https://www.kernel.org/doc/html/next/x86/sva.htmlhttps://blog.csdn.net/qq_45024274/article/details/129224989 SVA的概念https://www.kernel.org/doc/html/next/x86/sva.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Smmu","slug":"Linux-Smmu","permalink":"https://ray-jk-hong.github.io/tags/Linux-Smmu/"}]},{"title":"TLB","slug":"TLB","date":"2024-08-16T12:53:51.257Z","updated":"2024-08-16T12:53:51.257Z","comments":true,"path":"2024/08/16/TLB/","permalink":"https://ray-jk-hong.github.io/2024/08/16/TLB/","excerpt":"","text":"TLBTLB介绍TLB是一个cache、是保存MMU最近转换过的内容(TLB hit)。在每次MMU地址转换的时候、都会先查看TLB中是否存在、如果有的话就可以直接访问。如果TLB中没有(TLB miss)、就会通过MMU做转换并保存在TLB中。TLB中不仅保存虚拟地址和对应的物理地址、也保存1) attributes such as memory type (见memory ordering)2) cache policies3) access permissions4) the Address Space ID (ASID), and the Virtual Machine ID (VMID)。 如果MMU页表在建立之后、中途需要调整变化、在修改完MMU对应的页表之后、就要刷新(invalidate)TLB。 TLB刷新TLBI命令就是负责刷新TLB。 TLBI {IS} {, } type字段：ALL：刷新所有TLB entryVMALL: 刷新所有stage 1TLB entry https://aijishu.com/a/1060000000381352","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"TLB","slug":"TLB","permalink":"https://ray-jk-hong.github.io/tags/TLB/"}]},{"title":"Workqueue","slug":"Workqueue","date":"2024-08-16T12:53:51.257Z","updated":"2024-08-16T12:53:51.257Z","comments":true,"path":"2024/08/16/Workqueue/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Workqueue/","excerpt":"","text":"alloc_workqueue WQ_UNBOUND的时候创建线程在内核态ps -ef可以看到alloc_workqueue调用的时候创建的线程。例如名字是xxx_wq的时候, 5.15版本是[xxx_wq]，6.6x版本是显示[kworker&#x2F;R-xxx_wq]。这个线程是在init_rescuer的时候创建的。什么时候在这个worker里边执行，后面再看一下。在queue_work的时候，真正执行的并不是上面的线程，一般都是在新创建的kworkerxxx执行。因为在alloc_workqueue的时候会选择条件一致的struct worker_pool并在这个上面执行。 work被中断抢占 work每次都执行在cpu0的时候被中断抢占，可以设置work的cpumask不让work在cpu0上执行1/sys/devices/virtual/workqueue# echo ffe &gt;cpumask Workqueue TraceTrace节点在sys trace目录&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;workqueue下，可以看到几个event节点。 12/sys/kernel/debug/tracing/events/workqueue/workqueue_activate_work workqueue_execute_end workqueue_execute_start workqueue_queue_work 所有的都打开就可以看到所有work执行的过程 Work消耗太多CPU Cycles(Top命令能看到)Worker线程通过ps命令打印如下： 1234root 5671 0.0 0.0 0 0 ? S 12:07 0:00 [kworker/0:1]root 5672 0.0 0.0 0 0 ? S 12:07 0:00 [kworker/1:2]root 5673 0.0 0.0 0 0 ? S 12:12 0:00 [kworker/0:0]root 5674 0.0 0.0 0 0 ? S 12:13 0:00 [kworker/1:0] 以下几种可能1.Work切换频繁 1234$echo workqueue:workqueue_queue_work &gt; /sys/kernel/tracing/set_event$cat /sys/kernel/tracing/trace_pipe &gt; out.txt (wait a few secs) ^C 这样可以看到所有的Work执行的情况。 1&lt;idle&gt;-0 [005] dNs.. 25598.686997: workqueue_queue_work: work struct=00000000b8691ef7 function=nf_flow_offload_work_gc workqueue=events_power_efficient req_cpu=24 cpu=-1 function&#x3D;‘Work函数名’就是Work的函数。 2.Work一次执行消耗太多使用如下方式查看kwork的调用栈。 1$cat /proc/THE_OFFENDING_KWORKER/stack THE_OFFENDING_KWORKER就是Worker线程的pid。 接口使用注意cancle_work_sync如果work的回调函数中有等待信号量等操作的时候，直接调用destroy_workqueue是会有报错的。正确的做法是: 1.唤醒work回调函数的信号量等待 2.调用cancel_work_sync等待work结束 3.调用destroy_workqueue销毁workqueue 参考Linux&#x2F;Documentation&#x2F;core-api&#x2F;workqueue.rsthttps://www.kernel.org/doc/html/v5.14/translations/zh_CN/core-api/workqueue.htmlhttps://events.static.linuxfound.org/sites/events/files/slides/Async%20execution%20with%20wqs.pdf https://www.kernel.org/doc/Documentation/core-api/workqueue.rst https://lwn.net/Articles/932431/ https://docs.kernel.org/core-api/workqueue.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Workqueue","slug":"Linux-Workqueue","permalink":"https://ray-jk-hong.github.io/tags/Linux-Workqueue/"}]},{"title":"Mmu","slug":"Mmu","date":"2024-08-16T12:53:51.256Z","updated":"2024-08-16T12:53:51.256Z","comments":true,"path":"2024/08/16/Mmu/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Mmu/","excerpt":"","text":"TTBR(Translation Table Base Register)寄存器TTBR寄存器介绍Stage1页表翻译时的页表基地址。TTBR0_EL1指定用户态页表基地址，TTBR1_EL1指定内核态的页表基地址。EL2和EL3有TTBR0但没有TTBR1(就是说EL2有TTBR0_EL2, EL3有TTBR_EL3，但没有TTBR1_EL2和TTRB1_EL3)。 所以EL2&#x2F;EL3模式下，只能使用0x0-0x0000FFFF_FFFFFFFF范围的地址 用户态不能直接访问MMU，当然也没有所谓的TTBR0_EL0，TTBR1_EL0之类的寄存器了。 TTBR地址范围确定在Linux系统中，0x0000_0000_0000_0000到0x0000_FFFF_FFFF_FFFF范围是被指定为用户态内存，0xFFFF_0000_0000_0000到0xFFFF_FFFF_FFFF_FFFF被指定为内核态地址。具体前面几个0表示走TTBR0_EL1或者几个F走TTBR1_EL1则是由TCR.TxSZ指定。 如何选择（D5-1736）在TCR.T0SZ, TCR.T1SZ都为16的场景下： 0x0000_开头的地址选择TTBR0_EL1为基地址开始页表翻译 0xFFFF_开头的地址选择TTBR1_EL1为基地址开始页表翻译 TTBR位分配 ASID是做什么？ VTTBR_EL2TCR(Translation Control Register)寄存器包含TCR_EL1&#x2F;TCR_EL2&#x2F;TCR_EL3这几种。决定EL0&#x2F;EL1在做地址翻译的时候选择哪个TTBR寄存器。例如：0x0000开始的地址，比如0x0000_ABCD_ABCD_ABCD这样的地址就是通过TTBR0_EL1开始地址翻译，而0xFFFF开始的地址，比如0xFFFF_ABCD_ABCD_ABCD这个地址就是通过TTBR1_EL1开始地址翻译。 TCR寄存器位分配以下是对TCR寄存器中的各位进行解释 TB （Top Byte ignored）（D8-2038）(MTE)表示top addr是ignore，还是用于MTE的计算看代码应该是kasa在用这个。 [arch/arm64/mm/proc.S]12345#ifdef CONFIG_KASAN_SW_TAGS#define TCR_KASAN_FLAGS TCR_TBI1#else#define TCR_KASAN_FLAGS 0#endif 参考文件：Linux目录下tools&#x2F;testing&#x2F;selftests&#x2F;arm64&#x2F;tags&#x2F;tags_test.c 可以查看TB是否使能。TB ignore使能的情况下，可以将高位用来做计数，实际地址访问的时候是会把高位给忽略掉的 .&#x2F;Documentation&#x2F;arm64&#x2F;memory-tagging-extension.rstprctl(PR_SET_TAGGED_ADDR_CTRL, flags, 0, 0, 0) TB的使用可以具体参考MTE使用篇。 A1ASID的选择，是使用TTBR_EL1中的，还是使用TTBR_EL0中的。 ASASID是使用8bit，还是使用16bit。 TTBRx_EL1中使用ASID的原因：https://blog.csdn.net/WANGYONGZIXUE/article/details/132996049 EPD包含EPD1、EPD0，表示TTBR_EL1&#x2F;TTBR_EL0是使能还是去使能。 T1SZ&#x2F;T0SZT0SZ: 表示TTBR0_EL1能表示的地址范围，地址范围的计算公式就是2^(64-T1SZ) Bytest:例如：如果用户态地址范围是48位虚拟地址，那这里应该配置T0SZ&#x3D;64-48&#x3D;16, 虚拟地址的范围是 2^(64-16) &#x3D; 0 ~ 0x0000_FFFF_FFFF_FFFFT1SZ: 和T0SZ一样，就是表示的是TTBR1_EL1的这样设置之后，0x0000_开头的地址都走TTBR0_EL1进行地址翻译，0xFFFFF_开头的地址就都走TTBR1_EL1进行地址翻译。Aarch64的tcr相关的定义都在arch&#x2F;arm64&#x2F;include&#x2F;asm&#x2F;pgtable-hwdef.h虚拟地址的位宽在linux用CONFIG_ARM64_VA_BITS定义 IPS（Intermediate Physical Address Size）中间级物理地址大小表示物理地址的范围： 000 32 bits, 4 GB. 001 36 bits, 64 GB. 010 40 bits, 1 TB. 011 42 bits, 4 TB. 100 44 bits, 16 TB. 101 48 bits, 256 TB. TG（Granule size）寻址的地址粒度（在Linux场景下，就是page_size对应的大小）01 16KByte10 4KByte11 64KByte MAIR (Memory Attribute Indirection Register)表示内存的属性。MAIR_ELx可以定义8种不同的属性。每种属性占8bit。8个bit分为前4个bit和后4个bit分别定义了不同的属性。 上面显示的RW分别别是读写属性。如果读写属性都有，就填1就可以了。 在Linux中，占了5种类型。MAIR_ELx属性在启动阶段就会设置好。设置的代码在arch&#x2F;arm64&#x2F;mm&#x2F;proc.S的__cpu_setup函数中。 1mov_q mair, MAIR_EL1_SET MAIR_EL1_SET定义如下： 123456789101112131415161718192021#define MAIR_ATTRIDX(attr, idx) ((attr) &lt;&lt; ((idx) * 8))#define MAIR_ATTR_DEVICE_nGnRnE UL(0x00)#define MAIR_ATTR_DEVICE_nGnRE UL(0x04)#define MAIR_ATTR_NORMAL_NC UL(0x44)#define MAIR_ATTR_NORMAL_TAGGED UL(0xf0)#define MAIR_ATTR_NORMAL UL(0xff)#define MAIR_ATTR_MASK UL(0xff)#define MT_NORMAL 0 #define MT_NORMAL_TAGGED 1 #define MT_NORMAL_NC 2 #define MT_DEVICE_nGnRnE 3#define MT_DEVICE_nGnRE 4 #define MAIR_EL1_SET \\ (MAIR_ATTRIDX(MAIR_ATTR_DEVICE_nGnRnE, MT_DEVICE_nGnRnE) | \\ MAIR_ATTRIDX(MAIR_ATTR_DEVICE_nGnRE, MT_DEVICE_nGnRE) | \\ MAIR_ATTRIDX(MAIR_ATTR_NORMAL_NC, MT_NORMAL_NC) | \\ MAIR_ATTRIDX(MAIR_ATTR_NORMAL, MT_NORMAL) | \\ MAIR_ATTRIDX(MAIR_ATTR_NORMAL, MT_NORMAL_TAGGED)) MAIR_ELx设置完成之后，在寻址的时候，就只需要通过lower attribute中的Attrindex中的index就可以知道这段页的内存是哪种属性了。例如如果Attrindex的值是0就是MT_NORMAL，如果是3就是MT_DEVICE_nGnRnE这种类型的。 参考TTBR寄存器中asid的作用https://blog.csdn.net/weixin_42135087/article/details/123369119","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"Mmu","slug":"Mmu","permalink":"https://ray-jk-hong.github.io/tags/Mmu/"}]},{"title":"Net","slug":"Net","date":"2024-08-16T12:53:51.256Z","updated":"2024-08-16T12:53:51.256Z","comments":true,"path":"2024/08/16/Net/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Net/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Net","slug":"Linux-Net","permalink":"https://ray-jk-hong.github.io/tags/Linux-Net/"}]},{"title":"Numa","slug":"Numa","date":"2024-08-16T12:53:51.256Z","updated":"2024-08-16T12:53:51.256Z","comments":true,"path":"2024/08/16/Numa/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Numa/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Numa","slug":"Linux-Numa","permalink":"https://ray-jk-hong.github.io/tags/Linux-Numa/"}]},{"title":"PowerManage","slug":"PowerManage","date":"2024-08-16T12:53:51.256Z","updated":"2024-08-16T12:53:51.256Z","comments":true,"path":"2024/08/16/PowerManage/","permalink":"https://ray-jk-hong.github.io/2024/08/16/PowerManage/","excerpt":"","text":"wakelock接口Suspend流程[include/linux/suspend.h]123456#define PM_HIBERNATION_PREPARE 0x0001 /* Going to hibernate */#define PM_POST_HIBERNATION 0x0002 /* Hibernation finished */#define PM_SUSPEND_PREPARE 0x0003 /* Going to suspend the system */#define PM_POST_SUSPEND 0x0004 /* Suspend finished */#define PM_RESTORE_PREPARE 0x0005 /* Going to restore a saved image */#define PM_POST_RESTORE 0x0006 /* Restore failed */ register_pm_notifier接口注册监听上述几个状态。在进入睡眠之前会发送PM_SUSPEND_PREPARE， 等睡眠结束（进入睡眠失败或者从睡眠中唤醒的时候）会再发送PM_POST_SUSPEND Suspend流程参考https://www.wowotech.net/pm_subsystem/suspend_and_resume.htmlhttps://blog.csdn.net/u012719256/article/details/52754492https://blog.csdn.net/MyArrow/article/details/8837756 用户态进程冻结进程冻结参考http://www.wowotech.net/pm_subsystem/237.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux PowerManage","slug":"Linux-PowerManage","permalink":"https://ray-jk-hong.github.io/tags/Linux-PowerManage/"}]},{"title":"Process Schedule","slug":"ProcessSchedule","date":"2024-08-16T12:53:51.256Z","updated":"2024-08-16T12:53:51.257Z","comments":true,"path":"2024/08/16/ProcessSchedule/","permalink":"https://ray-jk-hong.github.io/2024/08/16/ProcessSchedule/","excerpt":"","text":"进程sched事件追踪[sched事件追踪]123456789cd /sys/kernel/debug/tracing/events/schedecho 1 &gt; sched_switch/enableecho 1 &gt; sched_wakeup/enableecho 1 &gt; sched_wakeup_new/enableecho 1 &gt; sched_waking/enableecho 1 &gt; sched_process_fork/enableecho 1 &gt; sched_stat_runtime/enableecho 1 &gt; /sys/kernel/debug/tracing/events/irq/enableecho 1 &gt; /sys/kernel/debug/tracing/tracing_on 参考https://blog.csdn.net/weixin_51760563/article/details/122789480","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Process","slug":"Linux-Process","permalink":"https://ray-jk-hong.github.io/tags/Linux-Process/"}]},{"title":"Gic","slug":"Gic","date":"2024-08-16T12:53:51.255Z","updated":"2024-08-16T12:53:51.255Z","comments":true,"path":"2024/08/16/Gic/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Gic/","excerpt":"","text":"寄存器GICC_AHPPIR","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"Gic","slug":"Gic","permalink":"https://ray-jk-hong.github.io/tags/Gic/"}]},{"title":"Memblock","slug":"Memblock","date":"2024-08-16T12:53:51.255Z","updated":"2024-08-16T12:53:51.255Z","comments":true,"path":"2024/08/16/Memblock/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Memblock/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Memblock","slug":"Linux-Memblock","permalink":"https://ray-jk-hong.github.io/tags/Linux-Memblock/"}]},{"title":"Prctl","slug":"Linux踩内存问题定位","date":"2024-08-16T12:53:51.255Z","updated":"2024-08-16T12:53:51.255Z","comments":true,"path":"2024/08/16/Linux踩内存问题定位/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Linux%E8%B8%A9%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"打开Kasan选项打开page alloc&#x2F;free相关宏1234567CONFIG_PAGE_EXTENSION=yCONFIG_DEBUG_PAGEALLOC=yCONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT=y# CONFIG_PAGE_OWNER is not setCONFIG_PAGE_POISONING=yCONFIG_PAGE_POISONING_NO_SANITY=y原理：内核空间通过线性映射可以访问所有的内存（页表提前被创建），上述debug版本在内存释放后会释放线性映射，这样free的内存就不能在访问了","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Debug","slug":"Linux-Debug","permalink":"https://ray-jk-hong.github.io/tags/Linux-Debug/"}]},{"title":"DeviceTree","slug":"DeviceTree","date":"2024-08-16T12:53:51.254Z","updated":"2024-08-16T12:53:51.254Z","comments":true,"path":"2024/08/16/DeviceTree/","permalink":"https://ray-jk-hong.github.io/2024/08/16/DeviceTree/","excerpt":"","text":"编译与反编译命令 编译命令dtc -O dtb -o dest.dtb src.dts 反编译命令dtc -I dtb -O dts src.dtb &gt; des.dts 预留内存reserved-memory方式 在reserve-memory区域添加要预留的内存。下面就是在该区域添加了reserve:buffer@0区域。no-map表示该区域不要被映射进内核。预留后&#x2F;proc&#x2F;iomem也显示System RAM区域小于内存量。123456789reserved-memory &#123; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; ranges; reserved: buffer@0 &#123; no-map; reg = &lt;0x0 0x70000000 0x0 0x10000000&gt;; &#125;;&#125;; 在驱动dts节点添加引用1234reserved-driver@0 &#123; compatible = &quot;xlnx,reserved-memory&quot;; memory-region = &lt;&amp;reserved&gt;;&#125;; 在驱动代码中读驱动dts节点并使用1234567891011121314151617/* Get reserved memory region from Device-tree */np = of_parse_phandle(dev-&gt;of_node, &quot;memory-region&quot;, 0);if (!np) &#123; dev_err(dev, &quot;No %s specified\\n&quot;, &quot;memory-region&quot;); goto error1;&#125; rc = of_address_to_resource(np, 0, &amp;r);if (rc) &#123; dev_err(dev, &quot;No memory address assigned to the region\\n&quot;); goto error1;&#125; lp-&gt;paddr = r.start;lp-&gt;vaddr = memremap(r.start, resource_size(&amp;r), MEMREMAP_WB);dev_info(dev, &quot;Allocated reserved memory, vaddr: 0x%0llX, paddr: 0x%0llX\\n&quot;, (u64)lp-&gt;vaddr, lp-&gt;paddr); 通过DMA API预留12345678910111213141516reserved-memory &#123; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; ranges; reserved: buffer@0 &#123; compatible = &quot;shared-dma-pool&quot;; no-map; reg = &lt;0x0 0x70000000 0x0 0x10000000&gt;; &#125;;&#125;; reserved-driver@0 &#123; compatible = &quot;xlnx,reserved-memory&quot;; memory-region = &lt;&amp;reserved&gt;;&#125;; 然后在驱动代码中使用dma接口申请。 12345678910111213/* Initialize reserved memory resources */rc = of_reserved_mem_device_init(dev);if(rc) &#123; dev_err(dev, &quot;Could not get reserved memory\\n&quot;); goto error1;&#125; /* Allocate memory */dma_set_coherent_mask(dev, 0xFFFFFFFF);lp-&gt;vaddr = dma_alloc_coherent(dev, ALLOC_SIZE, &amp;lp-&gt;paddr, GFP_KERNEL);dev_info(dev, &quot;Allocated coherent memory, vaddr: 0x%0llX, paddr: 0x%0llX\\n&quot;, (u64)lp-&gt;vaddr, lp-&gt;paddr); CMA内存预留CMA跟上面DMA API预留方式一致，但多了两个属性。需要的属性：reusable;linux,cma-default 123456789101112reserved-memory &#123; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; ranges; reserved: buffer@0 &#123; compatible = &quot;shared-dma-pool&quot;; reusable; reg = &lt;0x0 0x70000000 0x0 0x10000000&gt;; linux,cma-default; &#125;; &#125;; 这样在设备启动的时候会显示： 1234[ 0.000000] Reserved memory: created CMA memory pool at 0x0000000070000000, size 256 MiB[ 0.000000] Reserved memory: initialized node buffer@0, compatible id shared-dma-pool simple-bus关键字","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux DeviceTree","slug":"Linux-DeviceTree","permalink":"https://ray-jk-hong.github.io/tags/Linux-DeviceTree/"}]},{"title":"Ebuf","slug":"Ebuf","date":"2024-08-16T12:53:51.254Z","updated":"2024-08-16T12:53:51.254Z","comments":true,"path":"2024/08/16/Ebuf/","permalink":"https://ray-jk-hong.github.io/2024/08/16/Ebuf/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Ebuf","slug":"Linux-Ebuf","permalink":"https://ray-jk-hong.github.io/tags/Linux-Ebuf/"}]},{"title":"Virt","slug":"Virt","date":"2024-08-15T10:25:51.989Z","updated":"2024-08-15T10:25:51.989Z","comments":true,"path":"2024/08/15/Virt/","permalink":"https://ray-jk-hong.github.io/2024/08/15/Virt/","excerpt":"","text":"参考https://www.cnblogs.com/LoyenWang/category/1828942.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Virt","slug":"Linux-Virt","permalink":"https://ray-jk-hong.github.io/tags/Linux-Virt/"}]},{"title":"Tasklet","slug":"Tasklet","date":"2024-08-14T10:01:22.767Z","updated":"2024-08-14T10:01:22.767Z","comments":true,"path":"2024/08/14/Tasklet/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Tasklet/","excerpt":"","text":"Tasklet执行方式大概有一些同学对tasklet的串行化还有点困惑，其实在单处理器上最好理解，所以本帖主要讨论多处理器上tasklet如何实现串行化：同一个tasklet对象同一时刻只能在一个处理器上运行。 在驱动程序中，tasklet是作为一种softirq形式出现的，所以对tasklet对象的提交一般发生在中断处理例程ISR中。一般一个tasklet用来对同一种中断类型进行后续的处理，所以完全不必要通过动态生成tasklet对象的方式在每次中断到来时重新生成一个tasklet对象来做后半段的处理。事实上Linux内核源码中，几乎所有的tasklet对象都是针对同一类型的中断只产生一个。如果有同学发现有例外的情况，请告诉我，将非常感谢。 假设某个中断发生，由CPU0来处理，在它的ISR中会调用tasklet_schedule来提交一个tasklet对象，假设为tasklet_obj，那么tasklet_schedule首先会为该tasklet对象tasklet_obj.state打上一个标志：TASKLET_STATE_SCHED，表明该tasklet对象被提交但还没有被运行，前述的打标志的操作是个原子，代码里是test_and_set_bit，这意味着如果同时有处理器CPU0和CPU1都来提交该tasklet_obj，那么只有一个会被成功提交，不过不用担心一个tasklet对象没被提交成功的话会有啥副作用，因为在softirq的处理阶段，一个tasklet对象上的处理函数可以一并处理掉外设若干次同一中断要做的事，最典型的，比如网卡连续接收到两个数据包，产生两个中断到两个不同处理器上，因为只有一个tasklet对象被提交，当该对象上的延迟函数被执行时，它会将两个数据包都读到系统内存中。 TASKLET_STATE_SCHED标志是确保tasklet串行化的第一道防线，但是如果该tasklet_obj对象已经被调度到处理器CPU0上运行了，那么TASKLET_STATE_SCHED标志会被清除，这意味着当一个tasklet_obj对象正在一个处理器上运行时，同一个tasklet_obj对象完全可以被提交到另一个处理器，比如CPU1上。那么这种情况下如何确保tasklet串行化呢，答案是tasklet_obj.state上为SMP系统增加的另一个标志位TASKLET_STATE_RUN，当一个tasklet_obj对象被某一处理器开始调度运行时，tasklet_action，也就是对应的softirq处理例程会通过tasklet_trylock来将该tasklet_obj对象的state成员打上标志TASKLET_STATE_RUN，这个操作同样是原子的，因此只会有一个处理器成功完成测试及打标志的动作，没成功的那个处理器上的tasklet_action会把当前的tasklet_obj重新加入到其所管理的tasklet_vec链表的尾部(因为一个相同的tasklet_obj对象已经在运行了，所以再期望其一并完成当前tasklet_obj所表示的任务变得不再可靠，这不同于刚提交时的情形，所以内核对此的策略是，把当前希望运行但是发现已经有同一个tasklet_obj对象的延迟函数正在被执行时，将当前对象加入到处理器tasklet_vec的链表尾部)。那先前成功的处理器就可以开始执行tasklet_obj对象上的延迟函数，执行完毕该tasklet_obj对象将从它所在的处理器tasklet_vec链表中消失，除非再次提交。所以一个成功执行的tasklet_obj对象的状态变化是：TASKLET_STATE_SCHED(被成功提交)–&gt;TASKLET_STATE_RUN | TASKLET_STATE_SCHED(被提交并且即将被调度运行)–&gt;TASKLET_STATE_RUN(正在被调度执行中)。 而一个不成功的tasklet要么在tasklet_schedule处就被泯灭掉，此时它根本不会出现在任何一个处理器的tasklet_vec链表中，要么是在同一个tasklet对象正在其他处理器上被执行时被成功提交，但是它目前暂时无法被执行，会被放到它所属的处理器tasklet_vec链表的尾部等待下一次被调度运行。 同一个tasklet在添加之后，在执行之前不能重新添加 同一个tasklet在执行的时候，可以重新添加(同一个CPU或者不同的CPU)，但不可能并行执行 Debug在sys trace目录下，可以打开相关的开关 12/sys/kernel/debug/tracing/events/irqsoftirq_entry softirq_exit softirq_raise tasklet_entry tasklet_exit tasklet_entry和tasklet_exit在5.10版本中是没有的，在6.9版本是有的。 参考http://blog.chinaunix.net/uid-23769728-id-3195496.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Tasklet","slug":"Linux-Tasklet","permalink":"https://ray-jk-hong.github.io/tags/Linux-Tasklet/"}]},{"title":"Timer","slug":"Timer","date":"2024-08-14T10:01:22.767Z","updated":"2024-08-14T10:01:22.767Z","comments":true,"path":"2024/08/14/Timer/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Timer/","excerpt":"","text":"Sleep接口注意在使用这类接口的时候，有一些原则需要遵守：（根据等待时间长短） 1.等待时间很短（&lt; ~10us） 这时最好使用udelay替换usleep_range。 2.睡眠时间在（10us ~ 20ms） 这个时间范围，最好使用usleep_range进行睡眠 3.睡眠时间较长（10ms+） 使用msleep或者msleep_interruptible。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Timer","slug":"Linux-Timer","permalink":"https://ray-jk-hong.github.io/tags/Linux-Timer/"}]},{"title":"Ftrace","slug":"Ftrace","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/Ftrace/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Ftrace/","excerpt":"","text":"Ftrace原理gcc编译时添加-pg编译选项。这个编译选项在函数开始处添加-bl指令 Ftrace跟踪函数123456789101112cd /sys/kernel/debug/tracing/echo 0 &gt; tracing_onecho 5 &gt; max_graph_depthecho function_graph &gt; current_tracerecho 1 &gt; options/func_stack_traceecho xxx &gt; set_graph_function ## set_ftrace_filter这个只能打印本函数没法打印子函数等，而set_graph_function是可以打印子函数，而且可以看到函数是不是在执行过程中被中断切出去了echo 0 &gt; trace echo 1 &gt; tracing_on./a.out 执行完程序echo 0 &gt; tracing_oncat trace set_graph_functionIf you want to trace only one function and all of its children,you just have to echo its name into set_graph_function: Trace-cmdhttps://man7.org/linux/man-pages/man1/trace-cmd-record.1.html使用trace-cmd record -e workqueue:workqueue_queue_work查看workqueue在执行时cpu 100%的问题https://community.frame.work/t/tracking-kworker-stuck-at-near-100-cpu-usage-with-ubuntu-22-04/23053?page=2 Trace EventTrace Event添加应用参考https://docs.kernel.org/trace/tracepoints.htmlhttps://www.kernel.org/doc/Documentation/trace/ftrace.txthttps://www.cnblogs.com/arnoldlu/p/7211249.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"}]},{"title":"CpuTopology","slug":"CpuTopology","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/CpuTopology/","permalink":"https://ray-jk-hong.github.io/2024/08/14/CpuTopology/","excerpt":"","text":"参考Documentation\\cputopology.txt","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/tags/Aarch64/"}]},{"title":"","slug":"NumaPerf","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/NumaPerf/","permalink":"https://ray-jk-hong.github.io/2024/08/14/NumaPerf/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/syscall.h&gt;static int nr_numa;static int open_device(const char *file)&#123; int fd = open(file, O_RDWR); if (fd &lt; 0) &#123; printf(&quot;open file /dev/sdma failed, err: %s\\n&quot;, strerror(errno)); exit(1); &#125; return fd;&#125;static bool huge_page = false;enum &#123; MPOL_DEFAULT, MPOL_PREFERRED, MPOL_BIND, MPOL_INTERLEAVE, MPOL_LOCAL, MPOL_MAX, /* always last member of enum */&#125;;#define MPOL_MF_MOVE (1 &lt;&lt; 1)#define SIZE_1M 0x100000UL#define SIZE_2M 0x200000ULstatic int testcase(size_t size, int fd, int src_nid, int dst_nid)&#123; int ret; long memcpy_dur; char *src, *dst; struct timeval start, end; size_t alloc_size = (size + SIZE_2M - 1UL) &amp; ~(SIZE_2M - 1UL); // align up to 2M int flags = MAP_PRIVATE | MAP_ANONYMOUS; if (huge_page) flags |= MAP_HUGETLB; src = mmap(NULL, alloc_size, PROT_WRITE | PROT_READ, flags, -1, 0); if (src == MAP_FAILED) &#123; printf(&quot;alloc src memory failed, %d\\n&quot;, errno); return -1; &#125; dst = mmap(NULL, alloc_size, PROT_WRITE | PROT_READ, flags, -1, 0); if (dst == MAP_FAILED) &#123; printf(&quot;alloc dst memory failed, %d\\n&quot;, errno); return -1; &#125; unsigned long nodemask = 1UL &lt;&lt; src_nid; ret = syscall(__NR_mbind, src, alloc_size, MPOL_BIND, &amp;nodemask, nr_numa, MPOL_MF_MOVE); if (ret &lt; 0) &#123; printf(&quot;mbind for src failed\\n&quot;); return -1; &#125; nodemask = 1UL &lt;&lt; dst_nid; ret = syscall(__NR_mbind, dst, alloc_size, MPOL_BIND, &amp;nodemask, nr_numa, MPOL_MF_MOVE); if (ret &lt; 0) &#123; printf(&quot;mbind for dst failed\\n&quot;); return -1; &#125; memset(src, &#x27;a&#x27;, size); memset(dst, &#x27;b&#x27;, size); gettimeofday(&amp;start, NULL); memcpy(dst, src, size); gettimeofday(&amp;end, NULL); memcpy_dur = 1000000 * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec; printf(&quot;src: %3d, dst: %3d, size: %8zd, memcpy: %12ld, %s\\n&quot;, src_nid, dst_nid, size, memcpy_dur, huge_page ? &quot;huge_page&quot; : &quot;normal_page&quot;); return 0;&#125;int main(int argc, char **argv)&#123; int ret, pasid; int src_nid, dst_nid; if (argc &lt; 6) &#123; printf(&quot;invalid input!\\n&quot; &quot;Usage:\\n\\t%s &lt;dev_file&gt; &lt;size&gt; &lt;src_nid&gt; &lt;dst_nid&gt; &lt;nr_numa&gt; [huge_page]\\n&quot;, argv[0]); return -1; &#125; if (argc == 7) huge_page = true; int fd = open_device(argv[1]); if (fd &lt; 0) &#123; perror(argv[1]); exit(1); &#125; size_t size = atoi(argv[2]); src_nid = atoi(argv[3]); dst_nid = atoi(argv[4]); nr_numa = atoi(argv[5]); testcase(size, fd, src_nid, dst_nid); close(fd); return 0;&#125;","categories":[],"tags":[]},{"title":"Perf","slug":"Perf","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/Perf/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Perf/","excerpt":"","text":"perf命令stat记录给定条件下事件的发生次数参数： -p 指定待分析进程的 pid（可以是多个，用,分隔列表） -t 指定待分析线程的 tid（可以是多个，用,分隔列表） -a 从所有 CPU 收集系统数据 -d -d：打印更详细的信息，可重复 3 次；追加显示L1 和 LLC data cache -d -d 追加显示dTLB 和 iTLB events -d -d -d 追加 prefetch events -r 重复运行命令 n 次，打印平均值。n 设为 0 时无限循环打印 -c 只统计指定 CPU 列表的数据，如：0,1,3或1-2 -A 与-a选项联用，不要将 CPU 计数聚合 输出结果分析： Task-clock-msecs：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。 Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，一般来说，频繁的进程切换有可能只是CPU正常调度下一个任务，也有可能是一些性能问题的外在表现，导致的原因可能是锁竞争，IO阻塞，硬件中断等。如果可能，频繁的进程切换是应该避免的。 Cache-misses：程序运行过程中总体的 cache 利用情况，对于性能敏感的程序来说，需要避免出现cache miss的情况。解决方法是对于程序频繁访问的热数据可以集中紧凑存储、程序不去大跨度离散的访问内存等等。 CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。 Cycles：处理器时钟，一条机器指令可能需要多个 cycles。 Instructions: 机器指令数目。 branches：为分支数量。 branch-misses：为分支预测时失败的数量。 recordlock内核锁性能需要编译选项的支持：CONFIG_LOCKDEP、CONFIG_LOCK_STAT。CONFIG_LOCKDEP ：defines acquired and release events.CONFIG_LOCK_STAT ：defines contended and acquired lock events.-i 输入文件-k sorting key，默认为acquired，还可以按contended、wait_total、wait_max和wait_min来 执行命令： perf lock record .&#x2F;xxx perf lock report 结果分析： Name 内核锁的名字 aquired 该锁被直接获得的次数，因为没有其它内核路径占用该锁，此时不用等待。 contended 该锁等待后获得的次数，此时被其它内核路径占用，需要等待 total wait 为了获得该锁，总共的等待时间。 max wait 为了获得该锁，最大的等待时间 min wait 为了获得该锁，最小的等待时间。 kmemslab分配器性能分析执行命令： perf kmem record .&#x2F;xxx perf kmem stat –caller –alloc -l 20结果分析： Callsite 内核代码中调用kmalloc和kfree的地方 Total_alloc&#x2F;Per 总共分配的内存大小，平均每次分配的内存大小 Total_req&#x2F;Per 总共请求的内存大小，平均每次请求的内存大小 Hit 调用的次数 Ping-pong kmalloc和kfree不被同一个CPU执行时的次数，这会导致cache效率降低。 Frag 碎片所占的百分比，碎片 &#x3D; 分配的内存 - 请求的内存，这部分是浪费的。 Alloc Ptr 有使用–alloc选项，还会看到此列，即所分配内存的地址(案例未使用) sched执行命令记录1秒钟的调度事件： 1perf sched record -- sleep 1 执行以下命令可以对生成的recored进行分析： perf sched map perf sched timehist top主要用于实时剖析各个函数在某个性能事件上的热度。利用perf top，能够直观地观察到当前的热点函数，并利用工具中内置的annotate功能，进一步查找热点指令 difftimechart由于perf timechart只记录线程粒度的信息，无法替代火焰图在函数级别上分析，需要结合火焰图一起使用 probe可以在程序中添加或者删除动态追踪点，即自定义事件。例如给malloc&#x2F;free等添加事件来追踪内存泄露情况： 123perf probe --exec=/lib64/libc-2.17.so --add malloc或者# perf stat -e probe_libc:free -e probe_libc:malloc -ag -p $(pgrep $process_name$) sleep 4 probe也可以在（内核）函数的某一行添加事件进行追踪：例如在schedule函数的12行处增加一个探测点 1perf probe -a schedule:12 若需要对自定义函数进行跟踪，和上文相似，假设我们定义了一个名为loop的函数 1#perf probe -x /root/code/test-perf-probe.o &quot;--add=loop&quot; 执行之后会显示： 1Added new event: probe_test_perf_probe:loop (on loop in /root/code/test_perf_probe.o) 然后就可以执行perf工具记录： 1perf record -e probe_test_perf_probe:loop -aR sleep 1 火焰图参考https://www.brendangregg.com/perf.html https://www.brendangregg.com/perf.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Perf","slug":"Linux-Perf","permalink":"https://ray-jk-hong.github.io/tags/Linux-Perf/"}]},{"title":"Proc-pagemap","slug":"Proc-pagemap","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/Proc-pagemap/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Proc-pagemap/","excerpt":"","text":"可以使用&#x2F;proc&#x2F;pid&#x2F;pagemap和&#x2F;proc&#x2F;pid&#x2F;map查看进程使用虚拟内存对应的物理地址 参考https://www.kernel.org/doc/Documentation/vm/pagemap.txt https://www.cnblogs.com/pengdonglin137/p/6802108.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Proc-pagemap","slug":"Linux-Proc-pagemap","permalink":"https://ray-jk-hong.github.io/tags/Linux-Proc-pagemap/"}]},{"title":"Proc-meminfo","slug":"Proc-meminfo","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/Proc-meminfo/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Proc-meminfo/","excerpt":"","text":"参考http://www.wowotech.net/memory_management/meminfo_1.htmlhttp://linuxperf.com/?cat=7","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Proc-meminfo","slug":"Linux-Proc-meminfo","permalink":"https://ray-jk-hong.github.io/tags/Linux-Proc-meminfo/"}]},{"title":"Security","slug":"Security","date":"2024-08-14T10:01:22.766Z","updated":"2024-08-14T10:01:22.766Z","comments":true,"path":"2024/08/14/Security/","permalink":"https://ray-jk-hong.github.io/2024/08/14/Security/","excerpt":"","text":"参考https://www.kernel.org/doc/html/v4.14/security/self-protection.html 内核将_text区域和rodata区域置位只读 内核代码区域置位只读[arch/arm64/mm/mmu.c]123456789void __init mark_linear_text_alias_ro(void)&#123; /* * Remove the write permissions from the linear alias of .text/.rodata */ update_mapping_prot(__pa_symbol(_text), (unsigned long)lm_alias(_text), (unsigned long)__init_begin - (unsigned long)_text, PAGE_KERNEL_RO);&#125; rodata区域置为只读需要使能CONFIG_STRICT_KERNEL_RWX或者是CONFIG_STRICT_MODULE_RWX12345678910111213141516171819202122232425262728#ifdef CONFIG_STRICT_KERNEL_RWXstatic void mark_readonly(void)&#123; if (rodata_enabled) &#123; /* * load_module() results in W+X mappings, which are cleaned * up with call_rcu(). Let&#x27;s make sure that queued work is * flushed so that we don&#x27;t hit false positives looking for * insecure pages which are W+X. */ rcu_barrier(); mark_rodata_ro(); rodata_test(); &#125; else pr_info(&quot;Kernel memory protection disabled.\\n&quot;);&#125;#elif defined(CONFIG_ARCH_HAS_STRICT_KERNEL_RWX)static inline void mark_readonly(void)&#123; pr_warn(&quot;Kernel memory protection not selected by kernel config.\\n&quot;);&#125;#elsestatic inline void mark_readonly(void)&#123; pr_warn(&quot;This architecture does not have kernel memory protection.\\n&quot;);&#125;#endif","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Security","slug":"Linux-Security","permalink":"https://ray-jk-hong.github.io/tags/Linux-Security/"}]},{"title":"StartUp","slug":"StartUp","date":"2024-08-13T13:15:23.310Z","updated":"2024-08-13T16:07:07.365Z","comments":true,"path":"2024/08/13/StartUp/","permalink":"https://ray-jk-hong.github.io/2024/08/13/StartUp/","excerpt":"","text":"内核入口内核入口需要查看lds链接脚本。KBUILD_LDS定义了链接脚本的路径：arch&#x2F;$(SRCARCH)&#x2F;kernel&#x2F;vmlinux.lds。 12345678# Linker scripts preprocessor (.lds.S -&gt; .lds)# ---------------------------------------------------------------------------quiet_cmd_cpp_lds_S = LDS $@ cmd_cpp_lds_S = $(CPP) $(cpp_flags) -P -U$(ARCH) \\ -D__ASSEMBLY__ -DLINKER_SCRIPT -o $@ $&lt;$(obj)/%.lds: $(src)/%.lds.S FORCE $(call if_changed_dep,cpp_lds_S) 从链接脚本 arch&#x2F;arm64&#x2F;kernel&#x2F;vmlinux.lds可以查到，程序的入口为 _text，镜像起始位置存放的是 .head.text段生成的指令 [arch/arm64/mm/proc.S]123456789101112OUTPUT_ARCH(aarch64)ENTRY(_text)SECTIONS&#123; . = ((((((-(((1)) &lt;&lt; ((((48))) - 1)))) + (0x08000000))) + (0x08000000))); .head.text : &#123; _text = .; KEEP(*(.head.text)) &#125; ...&#125; 搜索 .head.text，可以找到 include&#x2F;linux&#x2F;init.h对 __HEAD定义 .section “.head.text”,”ax” 1234/* For assembly routines */#define __HEAD .section &quot;.head.text&quot;,&quot;ax&quot;#define __INIT .section &quot;.init.text&quot;,&quot;ax&quot;#define __FINIT .previous 通过搜索 __HEAD，可以看到程序起始代码位于 arch&#x2F;arm64&#x2F;kernel&#x2F;head.S 从入口到start_kernel123456789101112131415161718192021+-- _text() /// 内核启动入口 \\-- primary_entry() +-- preserve_boot_args() /// 保存x0~x3到boot_args[0~3] +-- init_kernel_el() /// 根据内核运行异常等级进行配置，返回启动模式 | +-- init_el1() /// 通常情况下从EL1启动内核 | \\-- init_el2() /// 从EL2启动内核，用于开启VHE(Virtualization Host Extensions) +-- create_idmap() /// 建立恒等映射init_idmap_pg_dir和内核镜像映射init_pg_dir的页表 +-- __cpu_setup() /// 为开启MMU做的CPU初始化 \\-- __primary_switch() +-- __enable_mmu() /// 开启MMU，将init_idmap_pg_dir加载到ttbr0，reserved_pg_dir加载到ttbr1 +-- clear_page_tables() /// 清空init_pg_dir +-- create_kernel_mapping() /// 填充init_pg_dir +-- load_ttbr1() /// 将init_pg_dir加载到ttbr1 \\-- __primary_switched() /// 初始化init_task栈，设置VBAR_EL1，保存FDT地址，计算kimage_voffset，清空bss段 +-- set_cpu_boot_mode_flag()/// 设置__boot_cpu_mode变量 +-- early_fdt_map() | +-- early_fixmap_init() /// 尝试建立fixmap的页表，可能失败，后边init_feature_override会用到 | \\-- fixmap_remap_fdt() /// 如果成功建立fixmap页表，将fdt映射到fixmap的FIX_FDT区域 +-- init_feature_override() /// 根据BootLoader传入的bootargs，对一些参数的改写 +-- finalise_el2() /// Prefer VHE if possible \\-- start_kernel() /// 跳转到start_kernel执行","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux StartUp","slug":"Linux-StartUp","permalink":"https://ray-jk-hong.github.io/tags/Linux-StartUp/"}]},{"title":"Sysrq","slug":"Sysrq","date":"2024-08-13T13:15:23.310Z","updated":"2024-08-13T15:47:58.971Z","comments":true,"path":"2024/08/13/Sysrq/","permalink":"https://ray-jk-hong.github.io/2024/08/13/Sysrq/","excerpt":"","text":"代码路径Sysrq的代码路径在&#x2F;drivers&#x2F;tty&#x2F;sysrq.ccmd对应的处理函数是static const struct sysrq_key_op *sysrq_key_table[62] &#x3D; {};可以往&#x2F;proc&#x2F;sysrq-trigger中写入对应的cmd来触发某些事件例如往&#x2F;proc&#x2F;sysrq-trigger中写入c可以导致系统挂死：echo c &gt; &#x2F;proc&#x2F;sysrq-trigger 用法系统挂死echo c &gt; &#x2F;proc&#x2F;sysrq-trigger这个命令输入之后，系统就会挂死。 打印所有cpu的调用栈echo l &gt; &#x2F;proc&#x2F;sysrq-trigger 123456789101112131415161718192021222324252627282930313233343536373839404142434445[94891.950482] CPU: 5 PID: 6174 Comm: bash Not tainted 6.9.8-orbstack-00170-g7b4100b7ced4 #1[94891.950491] Hardware name: orbstack,virt (DT)[94891.950494] Call trace:[94891.950496] dump_backtrace+0xe8/0x110[94891.950509] show_stack+0x1c/0x30[94891.950512] dump_stack_lvl+0x38/0x78[94891.950522] dump_stack+0x14/0x20[94891.950525] nmi_cpu_backtrace+0xe0/0x138[94891.950573] nmi_trigger_cpumask_backtrace+0x90/0x180[94891.950576] arch_trigger_cpumask_backtrace+0x1c/0x30[94891.950578] sysrq_handle_showallcpus+0x20/0x30[94891.950585] __handle_sysrq+0x14c/0x158[94891.950586] write_sysrq_trigger+0xec/0x100[94891.950588] proc_reg_write+0x98/0x110[94891.950596] vfs_write+0x124/0x378[94891.950601] ksys_write+0x78/0xe8[94891.950603] __arm64_sys_write+0x20/0x30[94891.950605] do_el0_svc+0x90/0xe8[94891.950607] el0_svc+0x24/0x50[94891.950714] el0t_64_sync_handler+0x7c/0xf0[94891.950717] el0t_64_sync+0x14c/0x150[94891.950722] Sending NMI from CPU 5 to CPUs 0-4,6-9:[94891.950743] NMI backtrace for cpu 0[94891.951110] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 6.9.8-orbstack-00170-g7b4100b7ced4 #1[94891.951114] Hardware name: orbstack,virt (DT)[94891.951117] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)[94891.951120] pc : do_idle+0x100/0x2d8[94891.951127] lr : do_idle+0x100/0x2d8[94891.951133] sp : ffffc86062cf3dd0[94891.951135] x29: ffffc86062cf3de0 x28: 0000000040000000 x27: ffffc86062cfa000[94891.951140] x26: ffffc86062cfa748 x25: 0000000000000001 x24: ffffc86062cce000[94891.951143] x23: 0000000000000000 x22: ffffc86062d13780 x21: 00000003ffe00000[94891.951146] x20: 0000000000000000 x19: 0000000000000000 x18: 0000000000000005[94891.951149] x17: 00000000000000a2 x16: 0000000000000082 x15: 0000000000000010[94891.951151] x14: 0000000000000010 x13: ffffc86062cd38c0 x12: ffffffffffffffe1[94891.951154] x11: 000000000016080c x10: 0000000000000001 x9 : ffffc86062ccc470[94891.951157] x8 : 4000000000000000 x7 : 0000000000000000 x6 : 0000000000000000[94891.951159] x5 : 00002c74284a5c70 x4 : ffffc86062cf3c98 x3 : ffff151c4f0adec0[94891.951162] x2 : ffffc86062cf3d74 x1 : 0000000000000000 x0 : 00000000ffffffff[94891.951165] Call trace:[94891.951166] do_idle+0x100/0x2d8[94891.951168] cpu_startup_entry+0x38/0x48[94891.951170] rest_init+0xc8/0xd0[94891.951173] start_kernel+0x264/0x2b0[94891.951178] __primary_switched+0x80/0x90 将ftrace的buffer打印出来1echo z &gt; /proc/sysrq-trigger 输入完上面的命令之后，可以敲dmesg可以看到ftrace的buff里边的内容全部打印到内核日志中。 显示内存信息1echo m &gt; /proc/sysrq-trigger 之前敲dmesg可以看到打印的内存信息。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Sysrq","slug":"Linux-Sysrq","permalink":"https://ray-jk-hong.github.io/tags/Linux-Sysrq/"}]},{"title":"FileSystem","slug":"Vmcore","date":"2024-08-13T13:15:23.310Z","updated":"2024-08-13T13:15:23.310Z","comments":true,"path":"2024/08/13/Vmcore/","permalink":"https://ray-jk-hong.github.io/2024/08/13/Vmcore/","excerpt":"","text":"参考https://cloud.tencent.com/developer/article/1645411","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Vmcore","slug":"Linux-Vmcore","permalink":"https://ray-jk-hong.github.io/tags/Linux-Vmcore/"}]},{"title":"DeviceModel","slug":"DeviceModel","date":"2024-08-13T13:15:23.309Z","updated":"2024-08-13T13:15:23.309Z","comments":true,"path":"2024/08/13/DeviceModel/","permalink":"https://ray-jk-hong.github.io/2024/08/13/DeviceModel/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Driver","slug":"Linux-Driver","permalink":"https://ray-jk-hong.github.io/tags/Linux-Driver/"}]},{"title":"Gcc Tool","slug":"GccTool","date":"2024-08-13T13:15:23.309Z","updated":"2024-08-13T13:15:23.309Z","comments":true,"path":"2024/08/13/GccTool/","permalink":"https://ray-jk-hong.github.io/2024/08/13/GccTool/","excerpt":"","text":"Summaryar, nm, objdump, addr2line ar库文件的操作指令经常用法： 1234ar -t libname.a // 显示所有对象文件(.o文件)的列表.例： # ar t libtest.alibtest1.olibtest2.oar -rv libname.a objfile1.o objfile2.o ... objfilen.o // 把objfile1.o--objfilen.o打包成一个库文件 ar -help打印： d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。 m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用’a’，’b’，或’I’任选项移动到指定的位置。 p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。 q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。’a’，’b’，或’I’任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用’ar s’或ranlib来更新库的符号表索引。 r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 t：显示库的模块表清单。一般只显示模块名。 x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。 下面在看看可与操作选项结合使用的任选项： a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。 b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。 c：创建一个库。不管库是否存在，都将创建。 f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。 i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。 l：暂未使用 N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。 o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。 P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。 s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。 S：不创建目标文件索引，这在创建较大的库时能加快时间。 u：一般说来，命令ar r…插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。 v：该选项用来显示执行操作选项的附加信息。 V：显示ar的版本. nm列出目标文件的符号清单 1nm -s filename.a或者filename.o或者filename.out nm -help打印 -a或–debug-syms：显示调试符号。 -B：等同于–format&#x3D;bsd，用来兼容MIPS的nm。 -C或–demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。 -D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。 -f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。 -g或–extern-only：仅显示外部符号。 -n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。 -p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。 -P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。 -s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。 -r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。 –size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。 -t radix或–radix&#x3D;radix：使用radix进制显示符号值。radix只能为”d”表示十进制、”o”表示八进制或”x”表示十六进制。 –target&#x3D;bfdname：指定一个目标代码的格式，而非使用系统的默认格式。 -u或–undefined-only：仅显示没有定义的符号(那些外部符号)。 -l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。 -V或–version：显示nm的版本号。 –help：显示nm的任选项。 objdump常用命令： objdump -h file&lt;.o,.a,.out&gt; &#x2F;&#x2F; 查看对象文件所有的节sections.例如#objdump -h libtest1.o 123456789101112131415libtest1.o: file format elf32-i386Sections:Idx Name Size VMA LMA File off Algn 0 .text 00000014 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 00000000 00000000 00000048 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 00000000 00000000 00000048 2**2 ALLOC 3 .rodata 0000000e 00000000 00000000 00000048 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 0000001f 00000000 00000000 00000056 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 00000000 00000000 00000075 2**0 CONTENTS, READONLY objdump -t 查看对象文件所有的符号列表，相当于 nm -s objfilename,如： #objdump -t libtest1.o 123456789101112libtest1.o: file format elf32-i386SYMBOL TABLE:00000000 l df *ABS* 00000000 libtest1.c00000000 l d .text 00000000 .text00000000 l d .data 00000000 .data00000000 l d .bss 00000000 .bss00000000 l d .rodata 00000000 .rodata00000000 l d .note.GNU-stack 00000000 .note.GNU-stack00000000 l d .comment 00000000 .comment00000000 g F .text 00000014 print_test100000000 *UND* 00000000 puts addr2line将可执行文件反汇编并打印对应文件的行号。 内核模块查看oops打印，看到挂死在xxx模块中，函数是func_xxx，偏移是0x100&#x2F;0x200。我们可以按照如下方法打印具体的行号。 反汇编aarch64-linux-gnu-objdump -D xxx.o &gt; out.txt在out.txt中找到func_xxx的开始地址。假设开始地址是0x800。 计算挂死的地址0x800 + 0x100 &#x3D; 0x900。0x800是函数开始地址，0x100是偏移 打印aarch64-linux-gnu-addr2line -i -C -f -e xxx.o 900 内核跟上面一样，只需要将xxx.o文件替换成vmlinux就可以了。 参考https://blog.csdn.net/longbei9029/article/details/76397089","categories":[{"name":"Gcc Tool","slug":"Gcc-Tool","permalink":"https://ray-jk-hong.github.io/categories/Gcc-Tool/"}],"tags":[{"name":"Gcc Tool","slug":"Gcc-Tool","permalink":"https://ray-jk-hong.github.io/tags/Gcc-Tool/"}]},{"title":"Mte","slug":"Mte","date":"2024-08-13T13:15:23.309Z","updated":"2024-08-13T13:15:23.309Z","comments":true,"path":"2024/08/13/Mte/","permalink":"https://ray-jk-hong.github.io/2024/08/13/Mte/","excerpt":"","text":"参考https://blog.csdn.net/feelabclihu/article/details/121571741 https://www.kernel.org/doc/html/v5.12/arm64/memory-tagging-extension.html","categories":[{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"}],"tags":[{"name":"Mte","slug":"Mte","permalink":"https://ray-jk-hong.github.io/tags/Mte/"}]},{"title":"Kprobe","slug":"Kprobe","date":"2024-08-13T13:15:23.309Z","updated":"2024-08-13T13:15:23.309Z","comments":true,"path":"2024/08/13/Kprobe/","permalink":"https://ray-jk-hong.github.io/2024/08/13/Kprobe/","excerpt":"","text":"内核态注册https://docs.kernel.org/trace/kprobes.html 用户态使用Kprobe探测内核函数开启关闭Kprobe 开启：echo 1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable 关闭：echo 0 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;kprobes&#x2F;enable 设置Kprobe探测点 返回值打印：1echo &#x27;r 函数名 ret=$retval&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events 入参打印: x86平台使用%ax, %bx, %cx, %dx表示第0-3个参数。arm平台使用x0, x1, x2, x3来表示第0-3个参数。Linux4.x版本之后，应该都可以使用arg0, arg1等方式表示。 2.1 函数的参数直接打印值： X86打印第一个第二个参数: 1echo &#x27;p function_name a=%ax:s32 b=%bx:u64&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events ARM打印第一个和第二个参数: 1echo &#x27;p function_name a=%x0:x64 b=%x1&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events 这里参数:后面s32, u64, x64等都表示的是需要打印的类型。x64表示按照16禁止打印，数据位宽就是64bit（8字节） 2.2 函数参数是指针，打印指针里边的内容： 1echo &#x27;p function_name +0(%x1):x64 +8(%x1):x64 +16(%x1):x64&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events +0(指针)表示解引用指针。按照上面的打印，第二个参数就是指针，+0(%x1):x64就是表示第二个参数指针偏移0并按照x64方式打印。 查看结果1cat /sys/kernel/debug/tracing/trace 清空结果1echo &gt; /sys/kernel/debug/tracing/trace 查看调用栈1echo 1 &gt; /sys/kernel/debug/tracing/options/stacktrace 过滤入参1echo &#x27;arg2==期望的值&#x27; &gt; /sys/kernel/debug/tracing/events/kprobes/p_函数名_0/filter 挂死打印当内核panic的时候ftrace_dump函数会将trace缓冲区里边的内容打印到内核日志中。 1echo 1 &gt; /proc/sys/kernel/ftrace_dump_on_oops 例如：调用栈显示某个函数有挂死现象，则可以按照上述方式打开并跟踪参数情况，可以追踪哪些参数传到函数中导致的异常","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"}]},{"title":"Ptrace","slug":"Ptrace","date":"2024-08-13T13:15:23.309Z","updated":"2024-08-13T13:15:23.310Z","comments":true,"path":"2024/08/13/Ptrace/","permalink":"https://ray-jk-hong.github.io/2024/08/13/Ptrace/","excerpt":"","text":"参考https://www.cnblogs.com/mysky007/p/11047943.html","categories":[{"name":"Gcc Tool","slug":"Gcc-Tool","permalink":"https://ray-jk-hong.github.io/categories/Gcc-Tool/"}],"tags":[{"name":"Gcc Tool","slug":"Gcc-Tool","permalink":"https://ray-jk-hong.github.io/tags/Gcc-Tool/"}]},{"title":"PageTable","slug":"Pgtable","date":"2024-08-12T10:37:47.840Z","updated":"2024-08-13T15:26:14.424Z","comments":true,"path":"2024/08/12/Pgtable/","permalink":"https://ray-jk-hong.github.io/2024/08/12/Pgtable/","excerpt":"","text":"页表设置保存stage2的页表基地址PTE_SHAREDpgprot_val（PAGE_KERNEL）pteval_t这些都有什么不同 页表walk","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Pgtable","slug":"Pgtable","permalink":"https://ray-jk-hong.github.io/tags/Pgtable/"}]},{"title":"I2c Protocol","slug":"I2c Protocol","date":"2024-08-12T10:22:51.119Z","updated":"2024-08-12T10:22:51.119Z","comments":true,"path":"2024/08/12/I2c Protocol/","permalink":"https://ray-jk-hong.github.io/2024/08/12/I2c%20Protocol/","excerpt":"","text":"I2C协议综述I2C总线包含两条线，SDA(串行数据线)&#x2F;SDL(串行时钟线). 原理是通过SDA&#x2F;SDL的电平高低的时序控制来进行数据的传递。在空闲状态时，这两个线一般被上面所接的上拉电阻拉高，保持高电平。I2C是半双工通信方式，同一时间只能单向通信。通信速度根据通信模式如下：(1) 标准模式：100Kbit&#x2F;s(2) 快速模式：400Kbit&#x2F;s(3) 高速模式：3.4Mbit&#x2F;s。 I2C主设备&#x2F;从设备I2C的是分主设备与从设备的。 I2C通信时，通信设备之间的地位是平等的，分为主设备和从设备，其中主设备一个、从设备多个。主设备要主导整个通信过程，从设备根据I2C协议被动的响应主设备； 在I2C通信中，没有规定谁做主设备、谁做从设备，是通信双方自己协商的。一个设备在同一时间只能做主设备或者从设备，但是有的设备可以通过软件配置来决定在此次通信时做主设备还是从设备。 I2C总线I2C总线状态：I2C数据传输单位是一个字节(8bit)，数据前后要有一个开始信号和结束信号。根据SDA&#x2F;SDL电平高低，I2C总线状态可以分为如下几种： SDA&#x2F;SDL高电平：空闲 SDA由高变低，SDL高电平：开始信号 SDL由低变高：SDL高电平：结束信号 I2C总线状态转移：在开始条件产生后，总线出于忙状态，总线由数据传输的主从设备独占，其他I2C期间无法访问总线。在停止条件产生后，本次数据传输的主从设备将释放总线，总线再次出于空闲状态。 I2C数据传输：I2C发送完开始信号之后，&#x3D;&#x3D;主设备&#x3D;&#x3D; 在SCL线上产生每个时钟脉冲的过程中将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着&#x3D;&#x3D;从设备&#x3D;&#x3D;将拉低SDA线，回传给主设备一个应答位， 此时才认为一个字节真正的被传输完成。当然，并不是所有的字节传输都必须有一个应答位，比如：当从设备不能再接收主设备发送的数据时，从设备将回传一个否定应答位。ACK信号就是从设备在拉低SDA之后，再给一个SDL脉冲？","categories":[{"name":"I2C","slug":"I2C","permalink":"https://ray-jk-hong.github.io/categories/I2C/"}],"tags":[{"name":"I2c Protocol","slug":"I2c-Protocol","permalink":"https://ray-jk-hong.github.io/tags/I2c-Protocol/"}]},{"title":"Prctl","slug":"Prctl","date":"2024-08-12T10:22:51.119Z","updated":"2024-08-12T10:23:44.627Z","comments":true,"path":"2024/08/12/Prctl/","permalink":"https://ray-jk-hong.github.io/2024/08/12/Prctl/","excerpt":"","text":"参考https://man7.org/linux/man-pages/man2/prctl.2.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Prctl","slug":"Linux-Prctl","permalink":"https://ray-jk-hong.github.io/tags/Linux-Prctl/"}]},{"title":"TraceEvent","slug":"TraceEvent","date":"2024-08-10T10:31:17.359Z","updated":"2024-08-10T16:14:25.065Z","comments":true,"path":"2024/08/10/TraceEvent/","permalink":"https://ray-jk-hong.github.io/2024/08/10/TraceEvent/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"}]},{"title":"Kvm","slug":"Kvm","date":"2024-08-10T10:31:17.358Z","updated":"2024-08-10T16:14:38.666Z","comments":true,"path":"2024/08/10/Kvm/","permalink":"https://ray-jk-hong.github.io/2024/08/10/Kvm/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Virt","slug":"Linux-Virt","permalink":"https://ray-jk-hong.github.io/tags/Linux-Virt/"}]},{"title":"HugeTLB","slug":"HugeTLB","date":"2024-08-10T10:31:17.357Z","updated":"2024-08-10T16:13:37.995Z","comments":true,"path":"2024/08/10/HugeTLB/","permalink":"https://ray-jk-hong.github.io/2024/08/10/HugeTLB/","excerpt":"","text":"参考https://blog.csdn.net/wangquan1992/article/details/103963108https://blog.csdn.net/hbuxiaofei/article/details/128402495https://blog.csdn.net/tony_vip/article/details/113791585 https://students.mimuw.edu.pl/ZSO/Wyklady/11_extXfs/TransparentHugePages.pdf 为什么使用大页大页提高性能大页能提高性能的原理：MMU翻译页表，按照2MB翻译，到PMD这层就可以了，不用翻译到PTE阶段。 大页类型HugeTLB机制： hstate管理大页，从伙伴系统申请，由order值决定大小。小于order的由伙伴系统申请，大于order的由memblock预留内存中申请或者调用alloc_cont_range申请。 HugeTLB机制：hugetlbfs文件系统 (1) HugeTLB就是透过hugetlbfs方式向文件系统提供使用HugeTLB大页机制 (2) hugetlbfs创建的文件可以被读系统调用操作，但不允许写系统调用操作，可以mmap映射 复合大页（Compound pages）：多个page组合起来管理连续内存空间透明大页（Transparent Huge Pages）：伙伴系统直接动态分配 透明大页机制介绍：khugepaged线程 Hash表是为了便于通过mm_struct指针地址，来找到对应的mm_slot结构 Khugepaged_scan管理的链表是透明大页遍历扫描的链表，透明大页遍历每个mm_slot 的mm_struct 通过mm_struct，遍历每个vma数据结构，扫描vma的地址空间，每次按2M大小扫描对应的pte内容 透明大页由于性能抖动以及挂死等问题，被禁用：https://www.pingcap.com/blog/transparent-huge-pages-why-we-disable-it-for-databases/ 如何使用大页用户态使用大页 用户态使用大页有以下几种方法： mount一个特殊的hugetlbfs文件系统，在上面创建文件，然后用mmap()进行访问, 但文件是只读的。也可以使用libhugetlbfs。 shmget&#x2F;shmat，调用shmget申请共享内存加上SHM_HUGETLB标志。 mmap()时指定MAAP_HUGETLB标志。 memfd的memfd_create传MFD_HUGETLB标记 mmap方式使用示例 cat &#x2F;proc&#x2F;meminfo | grep -i huge查看大页预留情况AnonHugePages: 2048 kBHugePages_Total: 200HugePages_Free: 200HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kB 预留大页（200个大页）echo 200 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;nr_huagepages或者sysctl vm.nr_hugepages&#x3D;200 mmap + memset的时候，在mmap参数中添加MAP_HUGETLB申请使用大页例如：(1) 申请使用大页 size &#x3D; 2 * 1024 * 1024; addr &#x3D; mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | 0x40000 &#x2F;MAP_HUGETLB&#x2F;, -1, 0); memset(addr, 0, size);(2) 重新查看大页使用情况 AnonHugePages: 2048 kB HugePages_Total: 200 HugePages_Free: 199 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB mount hugetlbfs方式示例 libhugetlbfs：使用大页，将用户态程序的text&#x2F;data&#x2F;BSS保存到大页功能，提高性能 shmemget方式示例 shmem大页：https://stackoverflow.com/questions/40777684/create-huge-page-shared-memory-for-ipc-in-linux 内核态申请大页","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux MM","slug":"Linux-MM","permalink":"https://ray-jk-hong.github.io/tags/Linux-MM/"}]},{"title":"Rcu (Read Copy Update)","slug":"Rcu","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-10T16:13:48.756Z","comments":true,"path":"2024/08/09/Rcu/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Rcu/","excerpt":"","text":"参考https://zhuanlan.zhihu.com/p/30583695http://www.wowotech.net/kernel_synchronization/rcu_fundamentals.htmlhttp://3ms.huawei.com/km/blogs/details/12175655 http://3ms.huawei.com/km/blogs/details/5886747https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit http://3ms.huawei.com/km/blogs/details/125081 例子：https://github.com/jinb-park/rcu_example/blob/master/list_rcu_example.c","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux RCU","slug":"Linux-RCU","permalink":"https://ray-jk-hong.github.io/tags/Linux-RCU/"}]},{"title":"Spinlock","slug":"Spinlock","date":"2024-08-09T10:53:15.490Z","updated":"2024-08-13T16:39:20.843Z","comments":true,"path":"2024/08/09/Spinlock/","permalink":"https://ray-jk-hong.github.io/2024/08/09/Spinlock/","excerpt":"","text":"Spinlock嵌套使用spinlock锁的类型有以下几种： spin_lock&#x2F;spin_unlock spin_lock_bh&#x2F;spin_unlock_bh spin_lock_irq&#x2F;spin_unlock_irq spin_lock_irqsave&#x2F;spin_unlock_irqrestorespinlock锁的严格程度是由弱到强。弱的spinlock类型不能被强的spinlock类型给嵌套。 spin_lock_irq套spin_lock_bh如下图所示，spin_lock_irq套了spin_lock_bh来保护临界区的函数，分别在进程上下文和tasklet中都被调用。 因为在spin_unlock_bh函数中，会查看当前是否有堆积的tasklet并直接调用do_softirq进行调用，导致spin_lock_irq死锁。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux Spinlock","slug":"Linux-Spinlock","permalink":"https://ray-jk-hong.github.io/tags/Linux-Spinlock/"}]},{"title":"FileSystem","slug":"FileSystem","date":"2024-08-09T10:53:15.489Z","updated":"2024-08-10T16:13:28.241Z","comments":true,"path":"2024/08/09/FileSystem/","permalink":"https://ray-jk-hong.github.io/2024/08/09/FileSystem/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"}],"tags":[{"name":"Linux File System","slug":"Linux-File-System","permalink":"https://ray-jk-hong.github.io/tags/Linux-File-System/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ray-jk-hong.github.io/categories/Linux/"},{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/categories/Aarch64/"},{"name":"Gcc Tool","slug":"Gcc-Tool","permalink":"https://ray-jk-hong.github.io/categories/Gcc-Tool/"},{"name":"I2C","slug":"I2C","permalink":"https://ray-jk-hong.github.io/categories/I2C/"}],"tags":[{"name":"Linux Cgroup","slug":"Linux-Cgroup","permalink":"https://ray-jk-hong.github.io/tags/Linux-Cgroup/"},{"name":"Linux Smmu","slug":"Linux-Smmu","permalink":"https://ray-jk-hong.github.io/tags/Linux-Smmu/"},{"name":"TLB","slug":"TLB","permalink":"https://ray-jk-hong.github.io/tags/TLB/"},{"name":"Linux Workqueue","slug":"Linux-Workqueue","permalink":"https://ray-jk-hong.github.io/tags/Linux-Workqueue/"},{"name":"Mmu","slug":"Mmu","permalink":"https://ray-jk-hong.github.io/tags/Mmu/"},{"name":"Linux Net","slug":"Linux-Net","permalink":"https://ray-jk-hong.github.io/tags/Linux-Net/"},{"name":"Linux Numa","slug":"Linux-Numa","permalink":"https://ray-jk-hong.github.io/tags/Linux-Numa/"},{"name":"Linux PowerManage","slug":"Linux-PowerManage","permalink":"https://ray-jk-hong.github.io/tags/Linux-PowerManage/"},{"name":"Linux Process","slug":"Linux-Process","permalink":"https://ray-jk-hong.github.io/tags/Linux-Process/"},{"name":"Gic","slug":"Gic","permalink":"https://ray-jk-hong.github.io/tags/Gic/"},{"name":"Linux Memblock","slug":"Linux-Memblock","permalink":"https://ray-jk-hong.github.io/tags/Linux-Memblock/"},{"name":"Linux Debug","slug":"Linux-Debug","permalink":"https://ray-jk-hong.github.io/tags/Linux-Debug/"},{"name":"Linux DeviceTree","slug":"Linux-DeviceTree","permalink":"https://ray-jk-hong.github.io/tags/Linux-DeviceTree/"},{"name":"Linux Ebuf","slug":"Linux-Ebuf","permalink":"https://ray-jk-hong.github.io/tags/Linux-Ebuf/"},{"name":"Linux Virt","slug":"Linux-Virt","permalink":"https://ray-jk-hong.github.io/tags/Linux-Virt/"},{"name":"Linux Tasklet","slug":"Linux-Tasklet","permalink":"https://ray-jk-hong.github.io/tags/Linux-Tasklet/"},{"name":"Linux Timer","slug":"Linux-Timer","permalink":"https://ray-jk-hong.github.io/tags/Linux-Timer/"},{"name":"Linux Trace","slug":"Linux-Trace","permalink":"https://ray-jk-hong.github.io/tags/Linux-Trace/"},{"name":"Aarch64","slug":"Aarch64","permalink":"https://ray-jk-hong.github.io/tags/Aarch64/"},{"name":"Linux Perf","slug":"Linux-Perf","permalink":"https://ray-jk-hong.github.io/tags/Linux-Perf/"},{"name":"Linux Proc-pagemap","slug":"Linux-Proc-pagemap","permalink":"https://ray-jk-hong.github.io/tags/Linux-Proc-pagemap/"},{"name":"Linux Proc-meminfo","slug":"Linux-Proc-meminfo","permalink":"https://ray-jk-hong.github.io/tags/Linux-Proc-meminfo/"},{"name":"Linux Security","slug":"Linux-Security","permalink":"https://ray-jk-hong.github.io/tags/Linux-Security/"},{"name":"Linux StartUp","slug":"Linux-StartUp","permalink":"https://ray-jk-hong.github.io/tags/Linux-StartUp/"},{"name":"Linux Sysrq","slug":"Linux-Sysrq","permalink":"https://ray-jk-hong.github.io/tags/Linux-Sysrq/"},{"name":"Linux Vmcore","slug":"Linux-Vmcore","permalink":"https://ray-jk-hong.github.io/tags/Linux-Vmcore/"},{"name":"Linux Driver","slug":"Linux-Driver","permalink":"https://ray-jk-hong.github.io/tags/Linux-Driver/"},{"name":"Gcc Tool","slug":"Gcc-Tool","permalink":"https://ray-jk-hong.github.io/tags/Gcc-Tool/"},{"name":"Mte","slug":"Mte","permalink":"https://ray-jk-hong.github.io/tags/Mte/"},{"name":"Pgtable","slug":"Pgtable","permalink":"https://ray-jk-hong.github.io/tags/Pgtable/"},{"name":"I2c Protocol","slug":"I2c-Protocol","permalink":"https://ray-jk-hong.github.io/tags/I2c-Protocol/"},{"name":"Linux Prctl","slug":"Linux-Prctl","permalink":"https://ray-jk-hong.github.io/tags/Linux-Prctl/"},{"name":"Linux MM","slug":"Linux-MM","permalink":"https://ray-jk-hong.github.io/tags/Linux-MM/"},{"name":"Linux RCU","slug":"Linux-RCU","permalink":"https://ray-jk-hong.github.io/tags/Linux-RCU/"},{"name":"Linux Spinlock","slug":"Linux-Spinlock","permalink":"https://ray-jk-hong.github.io/tags/Linux-Spinlock/"},{"name":"Linux File System","slug":"Linux-File-System","permalink":"https://ray-jk-hong.github.io/tags/Linux-File-System/"}]}